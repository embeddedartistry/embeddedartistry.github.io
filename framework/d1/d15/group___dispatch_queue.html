<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry Framework: Dispatch Queues</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Artistry Framework
   </div>
   <div id="projectbrief">Embedded Systems C++ Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Dispatch Queues<div class="ingroups"><a class="el" href="../../d3/dd5/group___framework_utils.html">Framework Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Group of worker threads that enables asynchronous processing.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Dispatch Queues:</div>
<div class="dyncontent">
<center><table><tr><td><img src="../../d1/d15/group___dispatch_queue.jpg" border="0" alt="" usemap="#d1_2d15_2group______dispatch__queue"/>
<map name="d1_2d15_2group______dispatch__queue" id="d1_2d15_2group______dispatch__queue">
<area shape="rect"  href="../../d3/dd5/group___framework_utils.html" title="Embedded Framework utility classes and functions." alt="" coords="5,5,140,29"/>
<area shape="rect"  title="Group of worker threads that enables asynchronous processing." alt="" coords="188,5,312,29"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:d4/db3/classembutil_1_1_dispatch_queue___base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;</a></td></tr>
<tr class="memdesc:d4/db3/classembutil_1_1_dispatch_queue___base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dispatch queues.  <a href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">More...</a><br /></td></tr>
<tr class="separator:d4/db3/classembutil_1_1_dispatch_queue___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gacab6e8043611db736ce6383bbd5cfc6a"><td class="memTemplParams" colspan="2">template&lt;typename TFunc  = std::function&lt;void()&gt;, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </td></tr>
<tr class="memitem:gacab6e8043611db736ce6383bbd5cfc6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#gacab6e8043611db736ce6383bbd5cfc6a">embutil::DynamicDispatchQueue</a> = <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt; 0, 0, TFunc, TLock, TCond &gt;</td></tr>
<tr class="memdesc:gacab6e8043611db736ce6383bbd5cfc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch queue class supporting dynamic sizes and dynamic memory allocation.  <a href="../../d1/d15/group___dispatch_queue.html#gacab6e8043611db736ce6383bbd5cfc6a">More...</a><br /></td></tr>
<tr class="separator:gacab6e8043611db736ce6383bbd5cfc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179ebed9f4943970e58d123e15a88ab8"><td class="memTemplParams" colspan="2">template&lt;const size_t TSize, const size_t TThreadCount = 1, typename TFunc  = stdext::inplace_function&lt;void()&gt;, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </td></tr>
<tr class="memitem:ga179ebed9f4943970e58d123e15a88ab8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ga179ebed9f4943970e58d123e15a88ab8">embutil::StaticDispatchQueue</a> = <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;</td></tr>
<tr class="memdesc:ga179ebed9f4943970e58d123e15a88ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch queue specializatoin using only static memory allocation.  <a href="../../d1/d15/group___dispatch_queue.html#ga179ebed9f4943970e58d123e15a88ab8">More...</a><br /></td></tr>
<tr class="separator:ga179ebed9f4943970e58d123e15a88ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Group of worker threads that enables asynchronous processing. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="d4/db3/classembutil_1_1_dispatch_queue___base" id="d4/db3/classembutil_1_1_dispatch_queue___base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d4/db3/classembutil_1_1_dispatch_queue___base">&#9670;&nbsp;</a></span>embutil::DispatchQueue_Base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class embutil::DispatchQueue_Base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt;<br />
class embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;</h3>

<p>Base class for dispatch queues. </p>
<p>This templated base class supports both static and dynamic dispatch queue implementations.</p>
<p>This class is not intended to be used directly in a dispatch queue declaration. Instead, use one of the specializations:</p><ul>
<li><code>DynamicDispatchQueue</code></li>
<li><code>StaticDispatchQueue</code></li>
</ul>
<h1>Using a Dispatch Queue</h1>
<p>Users interact with a dispatch queue using the <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3" title="Dispatch an operation.">dispatch()</a> APIs. The dispatch queue can accept any functor: functions, function pointers, lambdas. The client passes a functor to the <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3" title="Dispatch an operation.">dispatch()</a> operation, which returns immediately to the client. The functor will be executed asynchronously on the next available dispatch thread.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="../../d0/d95/strtodg_8c.html#a6e21ba825183ae20ce05deeb6b55f40e">increment</a>(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    count++;</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DynamicDispatchQueue&lt;&gt;</a> q(num_threads);</div><div class="line">q.dispatch(count);</div><div class="line">q.dispatch([] { <a class="code" href="../../d3/d6b/printf_8h.html#a3cb9f0894fab1c8fbb0753c9c7c2a8d9">printf</a>(<span class="stringliteral">&quot;Hello from a lambda!\n&quot;</span>); });</div></div><!-- fragment --><p>Dispatch queues are used when an operation needs to run on a separate thread, but you don't want to use explicit thread management. They support asynchronous processing models. A common usage mode is to have the operation call <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3" title="Dispatch an operation.">dispatch()</a> to carry out the next step in a processing chain.</p>
<p>Dispatch queues cannot be copied or moved.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>The size of the storage queue. When TSize is 0, dynamic memory allocation will be used. Otherwise static memory types are used and the maximum number of operations is limited to TSize. </td></tr>
    <tr><td class="paramname">TThreadCount</td><td>The number of threads to use with the dispatch queue. </td></tr>
    <tr><td class="paramname">TFunc</td><td>The type representing a dispatch function prototype. Defaults to any functor which can be represented by <code>void(void)</code>. </td></tr>
    <tr><td class="paramname">TLock</td><td>Type to use for the lock. Can be overriden if a custom mutex/lock should be used. </td></tr>
    <tr><td class="paramname">TCond</td><td>Type to use for the condition variable. Can be overridden if a custom condition variable implementation should be used. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:adf6724c2a509d65280664f0623b7b0e2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#adf6724c2a509d65280664f0623b7b0e2">DispatchFunc_t</a> = TFunc</td></tr>
<tr class="memdesc:adf6724c2a509d65280664f0623b7b0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public alias for the dispatch functor type.  <a href="#adf6724c2a509d65280664f0623b7b0e2">More...</a><br /></td></tr>
<tr class="separator:adf6724c2a509d65280664f0623b7b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a253787397ef966a027a3ec8aeff6f6ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a253787397ef966a027a3ec8aeff6f6ff">DispatchQueue_Base</a> (<a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">thread_count</a>=1)</td></tr>
<tr class="memdesc:a253787397ef966a027a3ec8aeff6f6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an unnamed dispatch queue.  <a href="#a253787397ef966a027a3ec8aeff6f6ff">More...</a><br /></td></tr>
<tr class="separator:a253787397ef966a027a3ec8aeff6f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c49b3f525bf49e67b15dddbcb9381f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a0c49b3f525bf49e67b15dddbcb9381f6">DispatchQueue_Base</a> (const char *name, <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">thread_count</a>=1)</td></tr>
<tr class="memdesc:a0c49b3f525bf49e67b15dddbcb9381f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dispatch queue with a C-string name.  <a href="#a0c49b3f525bf49e67b15dddbcb9381f6">More...</a><br /></td></tr>
<tr class="separator:a0c49b3f525bf49e67b15dddbcb9381f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae481eb385e099afb775feab625bd3ddb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ae481eb385e099afb775feab625bd3ddb">DispatchQueue_Base</a> (const std::string &amp;name, <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">thread_count</a>=1)</td></tr>
<tr class="memdesc:ae481eb385e099afb775feab625bd3ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dispatch queue with a std::string name.  <a href="#ae481eb385e099afb775feab625bd3ddb">More...</a><br /></td></tr>
<tr class="separator:ae481eb385e099afb775feab625bd3ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ff3edbb720d6d74c6663534d7781a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ad4ff3edbb720d6d74c6663534d7781a8">DispatchQueue_Base</a> (const std::string_view &amp;name, <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">thread_count</a>=1)</td></tr>
<tr class="memdesc:ad4ff3edbb720d6d74c6663534d7781a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dispatch queue with a std::string name.  <a href="#ad4ff3edbb720d6d74c6663534d7781a8">More...</a><br /></td></tr>
<tr class="separator:ad4ff3edbb720d6d74c6663534d7781a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb051c5ba2425ea59aec1d4e4345cc8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a2eb051c5ba2425ea59aec1d4e4345cc8">~DispatchQueue_Base</a> ()</td></tr>
<tr class="memdesc:a2eb051c5ba2425ea59aec1d4e4345cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a2eb051c5ba2425ea59aec1d4e4345cc8">More...</a><br /></td></tr>
<tr class="separator:a2eb051c5ba2425ea59aec1d4e4345cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3262a4c27e0eb32c5f9f6e6f6f82df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#aca3262a4c27e0eb32c5f9f6e6f6f82df">DispatchQueue_Base</a> (const <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> &amp;)=delete</td></tr>
<tr class="memdesc:aca3262a4c27e0eb32c5f9f6e6f6f82df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#aca3262a4c27e0eb32c5f9f6e6f6f82df">More...</a><br /></td></tr>
<tr class="separator:aca3262a4c27e0eb32c5f9f6e6f6f82df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c2699b984007b99b028e5a9a111703"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a30c2699b984007b99b028e5a9a111703">operator=</a> (const <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> &amp;)=delete</td></tr>
<tr class="memdesc:a30c2699b984007b99b028e5a9a111703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#a30c2699b984007b99b028e5a9a111703">More...</a><br /></td></tr>
<tr class="separator:a30c2699b984007b99b028e5a9a111703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2a275f7bd99260e7ab8eca30c5a7c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a8a2a275f7bd99260e7ab8eca30c5a7c7">DispatchQueue_Base</a> (<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a8a2a275f7bd99260e7ab8eca30c5a7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor.  <a href="#a8a2a275f7bd99260e7ab8eca30c5a7c7">More...</a><br /></td></tr>
<tr class="separator:a8a2a275f7bd99260e7ab8eca30c5a7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaced0bf80ef69a069ae96cb26ef229c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#aeaced0bf80ef69a069ae96cb26ef229c">operator=</a> (<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:aeaced0bf80ef69a069ae96cb26ef229c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator.  <a href="#aeaced0bf80ef69a069ae96cb26ef229c">More...</a><br /></td></tr>
<tr class="separator:aeaced0bf80ef69a069ae96cb26ef229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab676d2c7132e3553831eeabb96f75ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3">dispatch</a> (const TFunc &amp;op)</td></tr>
<tr class="memdesc:ab676d2c7132e3553831eeabb96f75ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatch an operation.  <a href="#ab676d2c7132e3553831eeabb96f75ed3">More...</a><br /></td></tr>
<tr class="separator:ab676d2c7132e3553831eeabb96f75ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d87901ed46a30813eb070d5b796ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a01d87901ed46a30813eb070d5b796ed6">dispatch</a> (TFunc &amp;&amp;op)</td></tr>
<tr class="separator:a01d87901ed46a30813eb070d5b796ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7666459061c6c71e0ef72ca9bbdb58e0"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a7666459061c6c71e0ef72ca9bbdb58e0">getBoundDispatch</a> ()</td></tr>
<tr class="memdesc:a7666459061c6c71e0ef72ca9bbdb58e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a std::bind object for the instance's dispatch(const&amp;) function.  <a href="#a7666459061c6c71e0ef72ca9bbdb58e0">More...</a><br /></td></tr>
<tr class="separator:a7666459061c6c71e0ef72ca9bbdb58e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892c3130688b38c15be92c3ec968975e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a892c3130688b38c15be92c3ec968975e">getBoundMoveDispatch</a> ()</td></tr>
<tr class="memdesc:a892c3130688b38c15be92c3ec968975e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a std::bind object for the instance's dispatch(&amp;&amp;) function.  <a href="#a892c3130688b38c15be92c3ec968975e">More...</a><br /></td></tr>
<tr class="separator:a892c3130688b38c15be92c3ec968975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a73597c3fd04c88953b45ec9db204de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a1a73597c3fd04c88953b45ec9db204de">queue_size</a> () const</td></tr>
<tr class="memdesc:a1a73597c3fd04c88953b45ec9db204de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current size of the operation queue.  <a href="#a1a73597c3fd04c88953b45ec9db204de">More...</a><br /></td></tr>
<tr class="separator:a1a73597c3fd04c88953b45ec9db204de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6e36c901779b9d33c0d970b90e0803"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a0b6e36c901779b9d33c0d970b90e0803">capacity</a> ()</td></tr>
<tr class="memdesc:a0b6e36c901779b9d33c0d970b90e0803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of the operation queue.  <a href="#a0b6e36c901779b9d33c0d970b90e0803">More...</a><br /></td></tr>
<tr class="separator:a0b6e36c901779b9d33c0d970b90e0803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa58623b11c727afd36e174b54b79be7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">thread_count</a> ()</td></tr>
<tr class="memdesc:aaa58623b11c727afd36e174b54b79be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of threads used by this dispatch queue.  <a href="#aaa58623b11c727afd36e174b54b79be7">More...</a><br /></td></tr>
<tr class="separator:aaa58623b11c727afd36e174b54b79be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a8e31e4068fba145e19d9569ef2654b5b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a8e31e4068fba145e19d9569ef2654b5b">TVecType</a> = typename std::conditional&lt;(TSize==0), std::vector&lt; std::thread &gt;, etl::vector&lt; std::thread, TThreadCount &gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td></tr>
<tr class="memdesc:a8e31e4068fba145e19d9569ef2654b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the thread storage vector.  <a href="#a8e31e4068fba145e19d9569ef2654b5b">More...</a><br /></td></tr>
<tr class="separator:a8e31e4068fba145e19d9569ef2654b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24123d1d8aa6cefdd6e510a046943ed1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a24123d1d8aa6cefdd6e510a046943ed1">TQueueType</a> = typename std::conditional&lt;(TSize==0), std::queue&lt; TFunc &gt;, <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TSize &gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td></tr>
<tr class="memdesc:a24123d1d8aa6cefdd6e510a046943ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the operation storage queue.  <a href="#a24123d1d8aa6cefdd6e510a046943ed1">More...</a><br /></td></tr>
<tr class="separator:a24123d1d8aa6cefdd6e510a046943ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Member Functions</h3></td></tr>
<tr class="memitem:a20eaf92b8fe01dc362040b8d99770d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">dispatch_thread_handler</a> ()</td></tr>
<tr class="memdesc:a20eaf92b8fe01dc362040b8d99770d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Worker thread handler.  <a href="#a20eaf92b8fe01dc362040b8d99770d02">More...</a><br /></td></tr>
<tr class="separator:a20eaf92b8fe01dc362040b8d99770d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:ae2956e80c9ebc4eff1ca583b4cf027fc"><td class="memItemLeft" align="right" valign="top">const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ae2956e80c9ebc4eff1ca583b4cf027fc">name_</a></td></tr>
<tr class="memdesc:ae2956e80c9ebc4eff1ca583b4cf027fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the dispatch queue.  <a href="#ae2956e80c9ebc4eff1ca583b4cf027fc">More...</a><br /></td></tr>
<tr class="separator:ae2956e80c9ebc4eff1ca583b4cf027fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086746b81e4f146d0ab2e8cf6cae85c2"><td class="memItemLeft" align="right" valign="top">TLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a086746b81e4f146d0ab2e8cf6cae85c2">lock_</a></td></tr>
<tr class="memdesc:a086746b81e4f146d0ab2e8cf6cae85c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instance of the lock used to protect the operation queue.  <a href="#a086746b81e4f146d0ab2e8cf6cae85c2">More...</a><br /></td></tr>
<tr class="separator:a086746b81e4f146d0ab2e8cf6cae85c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ff2f365a8d89256cd619f457e76df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a8e31e4068fba145e19d9569ef2654b5b">TVecType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">threads_</a></td></tr>
<tr class="memdesc:a175ff2f365a8d89256cd619f457e76df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of threads which handle dispatch operations.  <a href="#a175ff2f365a8d89256cd619f457e76df">More...</a><br /></td></tr>
<tr class="separator:a175ff2f365a8d89256cd619f457e76df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98119766f532b6c6ba90e456fc03c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a24123d1d8aa6cefdd6e510a046943ed1">TQueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ae98119766f532b6c6ba90e456fc03c78">q_</a></td></tr>
<tr class="memdesc:ae98119766f532b6c6ba90e456fc03c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The operation queue instance.  <a href="#ae98119766f532b6c6ba90e456fc03c78">More...</a><br /></td></tr>
<tr class="separator:ae98119766f532b6c6ba90e456fc03c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578ba382dd0d682c806f12c293a9258f"><td class="memItemLeft" align="right" valign="top">TCond&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a578ba382dd0d682c806f12c293a9258f">cv_</a></td></tr>
<tr class="memdesc:a578ba382dd0d682c806f12c293a9258f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The condition variable which is used to notify dispatch threads.  <a href="#a578ba382dd0d682c806f12c293a9258f">More...</a><br /></td></tr>
<tr class="separator:a578ba382dd0d682c806f12c293a9258f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43f01024db97eaa461657b9d418bdc8"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d15/group___dispatch_queue.html#ac43f01024db97eaa461657b9d418bdc8">quit_</a> = <a class="el" href="../../dc/d6c/test__suite_8cpp.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:ac43f01024db97eaa461657b9d418bdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used to signal to threads that it is time to shutdown the queue.  <a href="#ac43f01024db97eaa461657b9d418bdc8">More...</a><br /></td></tr>
<tr class="separator:ac43f01024db97eaa461657b9d418bdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="adf6724c2a509d65280664f0623b7b0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6724c2a509d65280664f0623b7b0e2">&#9670;&nbsp;</a></span>DispatchFunc_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#adf6724c2a509d65280664f0623b7b0e2">DispatchFunc_t</a> =  TFunc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Public alias for the dispatch functor type. </p>

</div>
</div>
<a id="a24123d1d8aa6cefdd6e510a046943ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24123d1d8aa6cefdd6e510a046943ed1">&#9670;&nbsp;</a></span>TQueueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#a24123d1d8aa6cefdd6e510a046943ed1">TQueueType</a> =  typename std::conditional&lt;(TSize == 0), std::queue&lt;TFunc&gt;, <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt;TSize&gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type definition for the operation storage queue. </p>
<p>If TSize is 0, std::queue will be used (dynamic memory mode). Otherwise a <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue" title="Static-memory function queue that accepts functors of multiple sizes.">StaticFunctionQueue</a> of size TSize is used. </p>

</div>
</div>
<a id="a8e31e4068fba145e19d9569ef2654b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e31e4068fba145e19d9569ef2654b5b">&#9670;&nbsp;</a></span>TVecType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#a8e31e4068fba145e19d9569ef2654b5b">TVecType</a> =  typename std::conditional&lt;(TSize == 0), std::vector&lt;std::thread&gt;, etl::vector&lt;std::thread, TThreadCount&gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type definition for the thread storage vector. </p>
<p>If TSize is 0, std::vector will be used (dynamic memory mode). Otherwise an etl::vector of size TSize is used. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a253787397ef966a027a3ec8aeff6f6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253787397ef966a027a3ec8aeff6f6ff">&#9670;&nbsp;</a></span>DispatchQueue_Base() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an unnamed dispatch queue. </p>
<p>Constucts a dispatch queue with a generic name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count</td><td>Optional parameter that determines the number of threads associated with this queue. thread_count cannot exceed TThreadCount. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::thread_count()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</a>.</p>

</div>
</div>
<a id="a0c49b3f525bf49e67b15dddbcb9381f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c49b3f525bf49e67b15dddbcb9381f6">&#9670;&nbsp;</a></span>DispatchQueue_Base() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dispatch queue with a C-string name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count</td><td>Optional parameter that determines the number of threads associated with this queue. thread_count cannot exceed TThreadCount. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the dispatch queue. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::thread_count()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</a>.</p>

</div>
</div>
<a id="ae481eb385e099afb775feab625bd3ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae481eb385e099afb775feab625bd3ddb">&#9670;&nbsp;</a></span>DispatchQueue_Base() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dispatch queue with a std::string name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the dispatch queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d1/d15/group___dispatch_queue.html#a253787397ef966a027a3ec8aeff6f6ff" title="Create an unnamed dispatch queue.">DispatchQueue_Base()</a> uses a std::string_view, so a std::string input must remain valid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count</td><td>Optional parameter that determines the number of threads associated with this queue. thread_count cannot exceed TThreadCount. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::thread_count()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</a>.</p>

</div>
</div>
<a id="ad4ff3edbb720d6d74c6663534d7781a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ff3edbb720d6d74c6663534d7781a8">&#9670;&nbsp;</a></span>DispatchQueue_Base() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dispatch queue with a std::string name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the dispatch queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d1/d15/group___dispatch_queue.html#a253787397ef966a027a3ec8aeff6f6ff" title="Create an unnamed dispatch queue.">DispatchQueue_Base()</a> uses a std::string_view, so the original std::string must remain valid. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thread_count</td><td>Optional parameter that determines the number of threads associated with this queue. thread_count cannot exceed TThreadCount. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::thread_count()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</a>.</p>

</div>
</div>
<a id="a2eb051c5ba2425ea59aec1d4e4345cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb051c5ba2425ea59aec1d4e4345cc8">&#9670;&nbsp;</a></span>~DispatchQueue_Base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::~<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>The destructor notifies dispatch threads that it is time to quit. We must wait for threads to exit before destroying the class to prevent race conditions and memory faults. Once all threads are joined, the object is destructed. </p>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a578ba382dd0d682c806f12c293a9258f">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::cv_</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a086746b81e4f146d0ab2e8cf6cae85c2">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::lock_</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#ac43f01024db97eaa461657b9d418bdc8">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::quit_</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</a>.</p>

</div>
</div>
<a id="aca3262a4c27e0eb32c5f9f6e6f6f82df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3262a4c27e0eb32c5f9f6e6f6f82df">&#9670;&nbsp;</a></span>DispatchQueue_Base() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="a8a2a275f7bd99260e7ab8eca30c5a7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2a275f7bd99260e7ab8eca30c5a7c7">&#9670;&nbsp;</a></span>DispatchQueue_Base() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::<a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a0b6e36c901779b9d33c0d970b90e0803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6e36c901779b9d33c0d970b90e0803">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the capacity of the operation queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the capacity of the queue </dd></dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#ae98119766f532b6c6ba90e456fc03c78">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::q_</a>.</p>

</div>
</div>
<a id="ab676d2c7132e3553831eeabb96f75ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab676d2c7132e3553831eeabb96f75ed3">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">const TFunc &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dispatch an operation. </p>
<p>This call adds the operation to the function queue and notifies worker threads that new work is available.</p>
<p>The dispatch call returns immediately. Processing happens asynchronously whenever a worker thread is available for processing the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to dispatch to a worker thread. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../dc/da7/assert_8h.html#af576bf8ffa22a44e53018c67095ffbf0">assert</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a578ba382dd0d682c806f12c293a9258f">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::cv_</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a086746b81e4f146d0ab2e8cf6cae85c2">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::lock_</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#ae98119766f532b6c6ba90e456fc03c78">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::q_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#a7666459061c6c71e0ef72ca9bbdb58e0">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::getBoundDispatch()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a892c3130688b38c15be92c3ec968975e">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::getBoundMoveDispatch()</a>.</p>

</div>
</div>
<a id="a01d87901ed46a30813eb070d5b796ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d87901ed46a30813eb070d5b796ed6">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch </td>
          <td>(</td>
          <td class="paramtype">TFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="../../dc/da7/assert_8h.html#af576bf8ffa22a44e53018c67095ffbf0">assert</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a578ba382dd0d682c806f12c293a9258f">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::cv_</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a086746b81e4f146d0ab2e8cf6cae85c2">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::lock_</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#ae98119766f532b6c6ba90e456fc03c78">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::q_</a>.</p>

</div>
</div>
<a id="a20eaf92b8fe01dc362040b8d99770d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eaf92b8fe01dc362040b8d99770d02">&#9670;&nbsp;</a></span>dispatch_thread_handler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Worker thread handler. </p>
<p>Worker threads all utilize the same operational flow:</p>
<ul>
<li>Threads sleep until there is work in the queue (or quit_ is set)</li>
<li>Whenever work is available, an operation is popped from the queue and processed locally by the worker thread.</li>
<li>When there is no longer any work available, the worker thread sleeps until notified </li>
</ul>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a578ba382dd0d682c806f12c293a9258f">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::cv_</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a086746b81e4f146d0ab2e8cf6cae85c2">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::lock_</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#ae98119766f532b6c6ba90e456fc03c78">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::q_</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#ac43f01024db97eaa461657b9d418bdc8">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::quit_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#a253787397ef966a027a3ec8aeff6f6ff">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::DispatchQueue_Base()</a>.</p>

</div>
</div>
<a id="a7666459061c6c71e0ef72ca9bbdb58e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7666459061c6c71e0ef72ca9bbdb58e0">&#9670;&nbsp;</a></span>getBoundDispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::getBoundDispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a std::bind object for the instance's dispatch(const&amp;) function. </p>
<p>If you need to get the dispatch(const&amp;) variant for another class, use this function to avoid making your code messy with an insane std::bind call.</p>
<dl class="section return"><dt>Returns</dt><dd>std::bind construct which will map to the the dispatch(const&amp;) function for this queue instance. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch()</a>.</p>

</div>
</div>
<a id="a892c3130688b38c15be92c3ec968975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892c3130688b38c15be92c3ec968975e">&#9670;&nbsp;</a></span>getBoundMoveDispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::getBoundMoveDispatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a std::bind object for the instance's dispatch(&amp;&amp;) function. </p>
<p>If you need to get the dispatch(&amp;&amp;) variant for another class, use this function to avoid making your code messy with a stupid std::bind call.</p>
<dl class="section return"><dt>Returns</dt><dd>std::bind construct which will map to the the dispatch(&amp;&amp;) function for this queue instance. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch()</a>.</p>

</div>
</div>
<a id="a30c2699b984007b99b028e5a9a111703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c2699b984007b99b028e5a9a111703">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&amp; <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a id="aeaced0bf80ef69a069ae96cb26ef229c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaced0bf80ef69a069ae96cb26ef229c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&amp; <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator. </p>

</div>
</div>
<a id="a1a73597c3fd04c88953b45ec9db204de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a73597c3fd04c88953b45ec9db204de">&#9670;&nbsp;</a></span>queue_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::queue_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current size of the operation queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the current number of enqueued operations. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#ae98119766f532b6c6ba90e456fc03c78">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::q_</a>.</p>

</div>
</div>
<a id="aaa58623b11c727afd36e174b54b79be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa58623b11c727afd36e174b54b79be7">&#9670;&nbsp;</a></span>thread_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of threads used by this dispatch queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of threads associated with this dispatch queue </dd></dl>

<p class="reference">References <a class="el" href="../../d1/d15/group___dispatch_queue.html#a175ff2f365a8d89256cd619f457e76df">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#a253787397ef966a027a3ec8aeff6f6ff">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::DispatchQueue_Base()</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a578ba382dd0d682c806f12c293a9258f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578ba382dd0d682c806f12c293a9258f">&#9670;&nbsp;</a></span>cv_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TCond <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::cv_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The condition variable which is used to notify dispatch threads. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a2eb051c5ba2425ea59aec1d4e4345cc8">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::~DispatchQueue_Base()</a>.</p>

</div>
</div>
<a id="a086746b81e4f146d0ab2e8cf6cae85c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086746b81e4f146d0ab2e8cf6cae85c2">&#9670;&nbsp;</a></span>lock_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLock <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::lock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instance of the lock used to protect the operation queue. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a2eb051c5ba2425ea59aec1d4e4345cc8">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::~DispatchQueue_Base()</a>.</p>

</div>
</div>
<a id="ae2956e80c9ebc4eff1ca583b4cf027fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2956e80c9ebc4eff1ca583b4cf027fc">&#9670;&nbsp;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the dispatch queue. </p>

</div>
</div>
<a id="ae98119766f532b6c6ba90e456fc03c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98119766f532b6c6ba90e456fc03c78">&#9670;&nbsp;</a></span>q_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a24123d1d8aa6cefdd6e510a046943ed1">TQueueType</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::q_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The operation queue instance. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#a0b6e36c901779b9d33c0d970b90e0803">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::capacity()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#ab676d2c7132e3553831eeabb96f75ed3">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a1a73597c3fd04c88953b45ec9db204de">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::queue_size()</a>.</p>

</div>
</div>
<a id="ac43f01024db97eaa461657b9d418bdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac43f01024db97eaa461657b9d418bdc8">&#9670;&nbsp;</a></span>quit_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&gt; <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::quit_ = <a class="el" href="../../dc/d6c/test__suite_8cpp.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag used to signal to threads that it is time to shutdown the queue. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#a20eaf92b8fe01dc362040b8d99770d02">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::dispatch_thread_handler()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a2eb051c5ba2425ea59aec1d4e4345cc8">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::~DispatchQueue_Base()</a>.</p>

</div>
</div>
<a id="a175ff2f365a8d89256cd619f457e76df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175ff2f365a8d89256cd619f457e76df">&#9670;&nbsp;</a></span>threads_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount, typename TFunc = stdext::inplace_function&lt;void()&gt;, typename TLock = std::mutex, typename TCond = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d15/group___dispatch_queue.html#a8e31e4068fba145e19d9569ef2654b5b">TVecType</a> <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">embutil::DispatchQueue_Base</a>&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::threads_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of threads which handle dispatch operations. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/d15/group___dispatch_queue.html#a253787397ef966a027a3ec8aeff6f6ff">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::DispatchQueue_Base()</a>, <a class="el" href="../../d1/d15/group___dispatch_queue.html#aaa58623b11c727afd36e174b54b79be7">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::thread_count()</a>, and <a class="el" href="../../d1/d15/group___dispatch_queue.html#a2eb051c5ba2425ea59aec1d4e4345cc8">embutil::DispatchQueue_Base&lt; TSize, TThreadCount, TFunc, TLock, TCond &gt;::~DispatchQueue_Base()</a>.</p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gacab6e8043611db736ce6383bbd5cfc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacab6e8043611db736ce6383bbd5cfc6a">&#9670;&nbsp;</a></span>DynamicDispatchQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc  = std::function&lt;void()&gt;, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d15/group___dispatch_queue.html#gacab6e8043611db736ce6383bbd5cfc6a">embutil::DynamicDispatchQueue</a> = typedef <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt;0, 0, TFunc, TLock, TCond&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch queue class supporting dynamic sizes and dynamic memory allocation. </p>
<p>This dispatch queue contains a dynamicly sized queue and configurable thread count. The function queue is fully serial, so each operation will execute in order.</p>
<p>To use this queue as a serial queue, use a thread count of 1. With multiple threads, operations will be executed as soon as a thread is available.</p>
<dl class="section note"><dt>Note</dt><dd>This queue is only safe to call from contexts which can aquire mutexes. </dd>
<dd>
To instantiate with default TFunc type, use <code>DynamicDispatchQueue&lt;&gt;</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunc</td><td>The type representing a dispatch function prototype. Defaults to any functor which can be represented by <code>void(void)</code>. </td></tr>
    <tr><td class="paramname">TLock</td><td>Type to use for the lock. Can be overriden if a custom mutex/lock should be used. </td></tr>
    <tr><td class="paramname">TCond</td><td>Type to use for the condition variable. Can be overridden if a custom condition variable implementation should be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga179ebed9f4943970e58d123e15a88ab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179ebed9f4943970e58d123e15a88ab8">&#9670;&nbsp;</a></span>StaticDispatchQueue</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TSize, const size_t TThreadCount = 1, typename TFunc  = stdext::inplace_function&lt;void()&gt;, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/d15/group___dispatch_queue.html#ga179ebed9f4943970e58d123e15a88ab8">embutil::StaticDispatchQueue</a> = typedef <a class="el" href="../../d1/d15/group___dispatch_queue.html#d4/db3/classembutil_1_1_dispatch_queue___base">DispatchQueue_Base</a>&lt;TSize, TThreadCount, TFunc, TLock, TCond&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dispatch queue specializatoin using only static memory allocation. </p>
<p>This dispatch queue type uses a staticly sized queue and configurable thread count. The function queue is fully serial, so each operation will execute in order.</p>
<p>To use this queue as a serial queue, use a thread count of 1. With multiple threads, operations will be executed as soon as a thread is available.</p>
<p>TSize = size of the underlying queue in bytes</p>
<dl class="section note"><dt>Note</dt><dd>This queue is only safe to call from contexts which can aquire mutexes.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TSize</td><td>The size of the storage queue. When TSize is 0, dynamic memory allocation will be used. Otherwise static memory types are used and the maximum number of operations is limited to TSize. </td></tr>
    <tr><td class="paramname">TThreadCount</td><td>The number of threads to use with the dispatch queue. </td></tr>
    <tr><td class="paramname">TFunc</td><td>The type representing a dispatch function prototype. Defaults to any functor which can be represented by <code>void(void)</code>. </td></tr>
    <tr><td class="paramname">TLock</td><td>Type to use for the lock. Can be overriden if a custom mutex/lock should be used. </td></tr>
    <tr><td class="paramname">TCond</td><td>Type to use for the condition variable. Can be overridden if a custom condition variable implementation should be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
