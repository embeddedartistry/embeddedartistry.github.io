<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry Framework: Function Queue</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Artistry Framework
   </div>
   <div id="projectbrief">Embedded Systems C++ Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Function Queue<div class="ingroups"><a class="el" href="../../d3/dd5/group___framework_utils.html">Framework Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Queues for storing function objects.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Function Queue:</div>
<div class="dyncontent">
<center><table><tr><td><img src="../../d1/de1/group___function_queue.jpg" border="0" alt="" usemap="#d1_2de1_2group______function__queue"/>
<map name="d1_2de1_2group______function__queue" id="d1_2de1_2group______function__queue">
<area shape="rect"  title="Queues for storing function objects." alt="" coords="188,5,304,29"/>
<area shape="rect"  href="../../d3/dd5/group___framework_utils.html" title="Embedded Framework utility classes and functions." alt="" coords="5,5,140,29"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:d6/d41/classembutil_1_1_func_op"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">embutil::FuncOp</a></td></tr>
<tr class="memdesc:d6/d41/classembutil_1_1_func_op"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base Class for storing functions.  <a href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">More...</a><br /></td></tr>
<tr class="separator:d6/d41/classembutil_1_1_func_op"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dd/d91/classembutil_1_1_func_op_bound"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">embutil::FuncOpBound&lt; TFuncOp &gt;</a></td></tr>
<tr class="memdesc:dd/d91/classembutil_1_1_func_op_bound"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a bound function object.  <a href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">More...</a><br /></td></tr>
<tr class="separator:dd/d91/classembutil_1_1_func_op_bound"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:db/d7b/classembutil_1_1_static_function_queue"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;</a></td></tr>
<tr class="memdesc:db/d7b/classembutil_1_1_static_function_queue"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static-memory function queue that accepts functors of multiple sizes.  <a href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">More...</a><br /></td></tr>
<tr class="separator:db/d7b/classembutil_1_1_static_function_queue"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Queues for storing function objects. </p>
<p>Users should utilize the <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue" title="Static-memory function queue that accepts functors of multiple sizes.">embutil::StaticFunctionQueue</a> or embutil::DynamicFunctionQueue template specializations. Other type definitions are used to make the queue work properly. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="d6/d41/classembutil_1_1_func_op" id="d6/d41/classembutil_1_1_func_op"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d6/d41/classembutil_1_1_func_op">&#9670;&nbsp;</a></span>embutil::FuncOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class embutil::FuncOp</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Base Class for storing functions. </p>
<p>This base class represents a function operation stored in the function queue.</p>
<p>In order to support functors of different sizes in a single statically-allocated function queue, we need to provide a common interface for each size.</p>
<p>A functor is stored in multiple blocks of <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> objects. The derived class, <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a>, overloads <a class="el" href="../../d1/de1/group___function_queue.html#a0b475a608cdcd5b1cf559b58880852f2" title="Invoke the function.">exec()</a> to call the bound operation. </p>
</div><div class="dynheader">
Inheritance diagram for embutil::FuncOp:</div>
<div class="dyncontent">
<div class="center"><img src="../../d6/d8a/classembutil_1_1_func_op__inherit__graph.jpg" border="0" usemap="#embutil_1_1_func_op_inherit__map" alt="Inheritance graph"/></div>
<map name="embutil_1_1_func_op_inherit__map" id="embutil_1_1_func_op_inherit__map">
<area shape="rect"  title="Base Class for storing functions." alt="" coords="25,5,144,105"/>
<area shape="rect"  href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object." alt="" coords="5,153,163,280"/>
</map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:adb17e66ebccc85498600a78e2333117d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#adb17e66ebccc85498600a78e2333117d">~FuncOp</a> ()</td></tr>
<tr class="memdesc:adb17e66ebccc85498600a78e2333117d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#adb17e66ebccc85498600a78e2333117d">More...</a><br /></td></tr>
<tr class="separator:adb17e66ebccc85498600a78e2333117d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b475a608cdcd5b1cf559b58880852f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a0b475a608cdcd5b1cf559b58880852f2">exec</a> ()</td></tr>
<tr class="memdesc:a0b475a608cdcd5b1cf559b58880852f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the function.  <a href="#a0b475a608cdcd5b1cf559b58880852f2">More...</a><br /></td></tr>
<tr class="separator:a0b475a608cdcd5b1cf559b58880852f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5e1bce6d21d0bb1a59247dcf79e5b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a2e5e1bce6d21d0bb1a59247dcf79e5b6">operator()</a> ()</td></tr>
<tr class="memdesc:a2e5e1bce6d21d0bb1a59247dcf79e5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator() invokes the function.  <a href="#a2e5e1bce6d21d0bb1a59247dcf79e5b6">More...</a><br /></td></tr>
<tr class="separator:a2e5e1bce6d21d0bb1a59247dcf79e5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="adb17e66ebccc85498600a78e2333117d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb17e66ebccc85498600a78e2333117d">&#9670;&nbsp;</a></span>~FuncOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">embutil::FuncOp::~FuncOp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a0b475a608cdcd5b1cf559b58880852f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b475a608cdcd5b1cf559b58880852f2">&#9670;&nbsp;</a></span>exec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void embutil::FuncOp::exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the function. </p>
<p>Base class invocation does nothing. Derived <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> classes overload this for the actual execution. </p>

<p>Reimplemented in <a class="el" href="../../d1/de1/group___function_queue.html#af67e1994fc82c97e144e4bd80b6ddbf4">embutil::FuncOpBound&lt; TFuncOp &gt;</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/de1/group___function_queue.html#a2e5e1bce6d21d0bb1a59247dcf79e5b6">operator()()</a>.</p>

</div>
</div>
<a id="a2e5e1bce6d21d0bb1a59247dcf79e5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5e1bce6d21d0bb1a59247dcf79e5b6">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embutil::FuncOp::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator() invokes the function. </p>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a0b475a608cdcd5b1cf559b58880852f2">exec()</a>.</p>

</div>
</div>

</div>
</div>
<a name="dd/d91/classembutil_1_1_func_op_bound" id="dd/d91/classembutil_1_1_func_op_bound"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dd/d91/classembutil_1_1_func_op_bound">&#9670;&nbsp;</a></span>embutil::FuncOpBound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class embutil::FuncOpBound</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename TFuncOp&gt;<br />
class embutil::FuncOpBound&lt; TFuncOp &gt;</h3>

<p>Represents a bound function object. </p>
<p>A bound function object takes in an operation of any type and stores it as a private member. Since our queue is intended to support objects of different sizes, we decay to the <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> base class interface for managing the queue.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFuncOp</td><td>The function prototype to store in the bound object. </td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for embutil::FuncOpBound&lt; TFuncOp &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../de/d6b/classembutil_1_1_func_op_bound__inherit__graph.jpg" border="0" usemap="#embutil_1_1_func_op_bound_3_01_t_func_op_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="embutil_1_1_func_op_bound_3_01_t_func_op_01_4_inherit__map" id="embutil_1_1_func_op_bound_3_01_t_func_op_01_4_inherit__map">
<area shape="rect"  title="Represents a bound function object." alt="" coords="5,153,163,280"/>
<area shape="rect"  href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions." alt="" coords="25,5,144,105"/>
</map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a833cbeebda88b91b06cafe1c7e5eb24b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a833cbeebda88b91b06cafe1c7e5eb24b">FuncOpBound</a> (const TFuncOp &amp;op)</td></tr>
<tr class="memdesc:a833cbeebda88b91b06cafe1c7e5eb24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> object with an operation.  <a href="#a833cbeebda88b91b06cafe1c7e5eb24b">More...</a><br /></td></tr>
<tr class="separator:a833cbeebda88b91b06cafe1c7e5eb24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a24e888f3fc018a9ce2f78807129b18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a5a24e888f3fc018a9ce2f78807129b18">FuncOpBound</a> (TFuncOp &amp;&amp;op)</td></tr>
<tr class="memdesc:a5a24e888f3fc018a9ce2f78807129b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> object with an operation.  <a href="#a5a24e888f3fc018a9ce2f78807129b18">More...</a><br /></td></tr>
<tr class="separator:a5a24e888f3fc018a9ce2f78807129b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1124f235f0ff547b6306c8331504422"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#aa1124f235f0ff547b6306c8331504422">~FuncOpBound</a> () final=default</td></tr>
<tr class="memdesc:aa1124f235f0ff547b6306c8331504422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#aa1124f235f0ff547b6306c8331504422">More...</a><br /></td></tr>
<tr class="separator:aa1124f235f0ff547b6306c8331504422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67e1994fc82c97e144e4bd80b6ddbf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#af67e1994fc82c97e144e4bd80b6ddbf4">exec</a> () final</td></tr>
<tr class="memdesc:af67e1994fc82c97e144e4bd80b6ddbf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke the bound operation.  <a href="#af67e1994fc82c97e144e4bd80b6ddbf4">More...</a><br /></td></tr>
<tr class="separator:af67e1994fc82c97e144e4bd80b6ddbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5e1bce6d21d0bb1a59247dcf79e5b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a2e5e1bce6d21d0bb1a59247dcf79e5b6">operator()</a> ()</td></tr>
<tr class="memdesc:a2e5e1bce6d21d0bb1a59247dcf79e5b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">operator() invokes the function.  <a href="#a2e5e1bce6d21d0bb1a59247dcf79e5b6">More...</a><br /></td></tr>
<tr class="separator:a2e5e1bce6d21d0bb1a59247dcf79e5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:aa8af8edd39408fcd738755e5eef3705a"><td class="memItemLeft" align="right" valign="top">TFuncOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#aa8af8edd39408fcd738755e5eef3705a">op_</a></td></tr>
<tr class="memdesc:aa8af8edd39408fcd738755e5eef3705a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The bound functor.  <a href="#aa8af8edd39408fcd738755e5eef3705a">More...</a><br /></td></tr>
<tr class="separator:aa8af8edd39408fcd738755e5eef3705a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a833cbeebda88b91b06cafe1c7e5eb24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833cbeebda88b91b06cafe1c7e5eb24b">&#9670;&nbsp;</a></span>FuncOpBound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">embutil::FuncOpBound</a>&lt; TFuncOp &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">FuncOpBound</a> </td>
          <td>(</td>
          <td class="paramtype">const TFuncOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> object with an operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to bind. Can be any functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a24e888f3fc018a9ce2f78807129b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24e888f3fc018a9ce2f78807129b18">&#9670;&nbsp;</a></span>FuncOpBound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">embutil::FuncOpBound</a>&lt; TFuncOp &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">FuncOpBound</a> </td>
          <td>(</td>
          <td class="paramtype">TFuncOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> object with an operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to bind. Can be any functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1124f235f0ff547b6306c8331504422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1124f235f0ff547b6306c8331504422">&#9670;&nbsp;</a></span>~FuncOpBound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">embutil::FuncOpBound</a>&lt; TFuncOp &gt;::~<a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">FuncOpBound</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="af67e1994fc82c97e144e4bd80b6ddbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67e1994fc82c97e144e4bd80b6ddbf4">&#9670;&nbsp;</a></span>exec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">embutil::FuncOpBound</a>&lt; TFuncOp &gt;::exec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke the bound operation. </p>

<p>Reimplemented from <a class="el" href="../../d1/de1/group___function_queue.html#a0b475a608cdcd5b1cf559b58880852f2">embutil::FuncOp</a>.</p>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#aa8af8edd39408fcd738755e5eef3705a">embutil::FuncOpBound&lt; TFuncOp &gt;::op_</a>.</p>

</div>
</div>
<a id="a2e5e1bce6d21d0bb1a59247dcf79e5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e5e1bce6d21d0bb1a59247dcf79e5b6">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embutil::FuncOp::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>operator() invokes the function. </p>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a0b475a608cdcd5b1cf559b58880852f2">embutil::FuncOp::exec()</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="aa8af8edd39408fcd738755e5eef3705a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8af8edd39408fcd738755e5eef3705a">&#9670;&nbsp;</a></span>op_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFuncOp <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound">embutil::FuncOpBound</a>&lt; TFuncOp &gt;::op_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The bound functor. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/de1/group___function_queue.html#af67e1994fc82c97e144e4bd80b6ddbf4">embutil::FuncOpBound&lt; TFuncOp &gt;::exec()</a>.</p>

</div>
</div>

</div>
</div>
<a name="db/d7b/classembutil_1_1_static_function_queue" id="db/d7b/classembutil_1_1_static_function_queue"></a>
<h2 class="memtitle"><span class="permalink"><a href="#db/d7b/classembutil_1_1_static_function_queue">&#9670;&nbsp;</a></span>embutil::StaticFunctionQueue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class embutil::StaticFunctionQueue</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc = stdext::inplace_function&lt;void()&gt;&gt;<br />
class embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;</h3>

<p>Static-memory function queue that accepts functors of multiple sizes. </p>
<p>This class stores function objects of varying sizes in a single queue. If you were to manage a queue of stdext::inplace_function, you would have to increase the size of each element to accommodate the largest possible size. This is inefficient. Instead, we support varying sizes by using more complicated memory management.</p>
<p>If you want a dynamic memory alternative, use <code>std::queue&lt;std::function&gt;</code>.</p>
<h1>Using a Function Queue</h1>
<p>This class is intended to be used with functions of type <code>void(void)</code>. You can store functions with arguments in the queue, but you must use a std::bind expression to reduce the arguments.</p>
<p>Functors can be pushed to the queue using <a class="el" href="../../d1/de1/group___function_queue.html#a9b240436c483ac6ebce1a99da3fa2716" title="Add a function to the queue.">push()</a>. This API creates a <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> object and stores the element for future processing.</p>
<dl class="section note"><dt>Note</dt><dd>After the function is stored in the queue, it cannot be recreated explicitly. It is only accessible as a pointer to a <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> object.</dd></dl>
<p>Elements can be removed from the queue using <a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744" title="Get a copy of the functor at the front of the queue.">front()</a>. A std::unique_ptr is returned, ensuring that the memory will be returned to the function queue's pool once the caller is done with the function. This means that <a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744" title="Get a copy of the functor at the front of the queue.">front()</a> can only be called once per queue element - there is no peeking. <a class="el" href="../../d1/de1/group___function_queue.html#a75df7f31f6e11c704fbac829eb45accd" title="Remove the element at the front of the queue.">pop()</a> can then be called to remove the element from the front of the queue.</p>
<p>Invoking the function after <a class="el" href="../../d1/de1/group___function_queue.html#a75df7f31f6e11c704fbac829eb45accd" title="Remove the element at the front of the queue.">pop()</a> ensures two things:</p><ol type="1">
<li>The element is removed, enabling another thread to pop off the next function immediately.</li>
<li>The queue is not blocked while the function is executing.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Elements returned through <a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744" title="Get a copy of the functor at the front of the queue.">front()</a> cannot be directly invoked with operator(). Instead, the exec() API must be used.</dd></dl>
<p>Here is an example flow for removing elements from the function queue:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> op = std::move(q_.front());</div><div class="line">q_.pop();</div><div class="line"></div><div class="line">op-&gt;exec();</div></div><!-- fragment --><p>If a single thread is managing the queue, <a class="el" href="../../d1/de1/group___function_queue.html#a74503bd66e5b25698437d1a9284c6187" title="Remove the next functor from the front of the queue and execute it.">popAndExec()</a> can be used to remove the function from the queue and execute it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunc</td><td>The functor storage type, such as std::function or stdext::inplace_function. </td></tr>
    <tr><td class="paramname">TQueueElements</td><td>The number of elements to store in the queue. TQueueElements must be &gt; 0. </td></tr>
    <tr><td class="paramname">TLargestSize</td><td>The size of the largest expected allocation, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The total memory pool size in bytes is <code>(TQueueElements * TLargestSize)</code>. </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a8cfa6ba49a9a0a0fe91f693f3f908628"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a8cfa6ba49a9a0a0fe91f693f3f908628">StaticFunctionQueue</a> ()=default</td></tr>
<tr class="memdesc:a8cfa6ba49a9a0a0fe91f693f3f908628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a8cfa6ba49a9a0a0fe91f693f3f908628">More...</a><br /></td></tr>
<tr class="separator:a8cfa6ba49a9a0a0fe91f693f3f908628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b13df6c931de0c13ee8e2cba65250b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a0b13df6c931de0c13ee8e2cba65250b7">~StaticFunctionQueue</a> ()=default</td></tr>
<tr class="memdesc:a0b13df6c931de0c13ee8e2cba65250b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a0b13df6c931de0c13ee8e2cba65250b7">More...</a><br /></td></tr>
<tr class="separator:a0b13df6c931de0c13ee8e2cba65250b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916445f6ecdb29df45e324ebd90a343b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a916445f6ecdb29df45e324ebd90a343b">StaticFunctionQueue</a> (const <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:a916445f6ecdb29df45e324ebd90a343b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a916445f6ecdb29df45e324ebd90a343b">More...</a><br /></td></tr>
<tr class="separator:a916445f6ecdb29df45e324ebd90a343b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ecdbab120c73b703b53062ea6b99dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a01ecdbab120c73b703b53062ea6b99dc">operator=</a> (const <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> &amp;)=delete</td></tr>
<tr class="memdesc:a01ecdbab120c73b703b53062ea6b99dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#a01ecdbab120c73b703b53062ea6b99dc">More...</a><br /></td></tr>
<tr class="separator:a01ecdbab120c73b703b53062ea6b99dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55595067039b31dd3bdfa9e7dfa48e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a3f55595067039b31dd3bdfa9e7dfa48e">StaticFunctionQueue</a> (<a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a3f55595067039b31dd3bdfa9e7dfa48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor.  <a href="#a3f55595067039b31dd3bdfa9e7dfa48e">More...</a><br /></td></tr>
<tr class="separator:a3f55595067039b31dd3bdfa9e7dfa48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98db410978a103ae7abac3fe4652dc5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a98db410978a103ae7abac3fe4652dc5a">operator=</a> (<a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a98db410978a103ae7abac3fe4652dc5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator.  <a href="#a98db410978a103ae7abac3fe4652dc5a">More...</a><br /></td></tr>
<tr class="separator:a98db410978a103ae7abac3fe4652dc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b240436c483ac6ebce1a99da3fa2716"><td class="memTemplParams" colspan="2">template&lt;typename TFuncOp &gt; </td></tr>
<tr class="memitem:a9b240436c483ac6ebce1a99da3fa2716"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a9b240436c483ac6ebce1a99da3fa2716">push</a> (const TFuncOp &amp;op) noexcept</td></tr>
<tr class="memdesc:a9b240436c483ac6ebce1a99da3fa2716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a function to the queue.  <a href="#a9b240436c483ac6ebce1a99da3fa2716">More...</a><br /></td></tr>
<tr class="separator:a9b240436c483ac6ebce1a99da3fa2716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fd8921dda6d1285377426a603a3d6b"><td class="memTemplParams" colspan="2">template&lt;typename TFuncOp &gt; </td></tr>
<tr class="memitem:ad8fd8921dda6d1285377426a603a3d6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#ad8fd8921dda6d1285377426a603a3d6b">push</a> (TFuncOp &amp;&amp;op) noexcept</td></tr>
<tr class="separator:ad8fd8921dda6d1285377426a603a3d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74503bd66e5b25698437d1a9284c6187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a74503bd66e5b25698437d1a9284c6187">popAndExec</a> () noexcept</td></tr>
<tr class="memdesc:a74503bd66e5b25698437d1a9284c6187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the next functor from the front of the queue and execute it.  <a href="#a74503bd66e5b25698437d1a9284c6187">More...</a><br /></td></tr>
<tr class="separator:a74503bd66e5b25698437d1a9284c6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b28387b888b42fdc78b3bdc8ba3744"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744">front</a> () noexcept</td></tr>
<tr class="memdesc:a33b28387b888b42fdc78b3bdc8ba3744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a copy of the functor at the front of the queue.  <a href="#a33b28387b888b42fdc78b3bdc8ba3744">More...</a><br /></td></tr>
<tr class="separator:a33b28387b888b42fdc78b3bdc8ba3744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75df7f31f6e11c704fbac829eb45accd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a75df7f31f6e11c704fbac829eb45accd">pop</a> () noexcept</td></tr>
<tr class="memdesc:a75df7f31f6e11c704fbac829eb45accd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the element at the front of the queue.  <a href="#a75df7f31f6e11c704fbac829eb45accd">More...</a><br /></td></tr>
<tr class="separator:a75df7f31f6e11c704fbac829eb45accd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed8c5ecfc5bb180dc730c16b10d3830"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a1ed8c5ecfc5bb180dc730c16b10d3830">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a1ed8c5ecfc5bb180dc730c16b10d3830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the queue is empty.  <a href="#a1ed8c5ecfc5bb180dc730c16b10d3830">More...</a><br /></td></tr>
<tr class="separator:a1ed8c5ecfc5bb180dc730c16b10d3830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aed6b1d605293891eac53ecff8c6dc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a5aed6b1d605293891eac53ecff8c6dc5">size</a> () const noexcept</td></tr>
<tr class="memdesc:a5aed6b1d605293891eac53ecff8c6dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the current number of elements in the queue.  <a href="#a5aed6b1d605293891eac53ecff8c6dc5">More...</a><br /></td></tr>
<tr class="separator:a5aed6b1d605293891eac53ecff8c6dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabcbbc32198cb967f1631b930ed9994"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#acabcbbc32198cb967f1631b930ed9994">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:acabcbbc32198cb967f1631b930ed9994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity in elements.  <a href="#acabcbbc32198cb967f1631b930ed9994">More...</a><br /></td></tr>
<tr class="separator:acabcbbc32198cb967f1631b930ed9994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb81165041ca746367e56f72be2f82ec"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#adb81165041ca746367e56f72be2f82ec">capacity_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:adb81165041ca746367e56f72be2f82ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total memory consumed by this queue in bytes.  <a href="#adb81165041ca746367e56f72be2f82ec">More...</a><br /></td></tr>
<tr class="separator:adb81165041ca746367e56f72be2f82ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:ac12dd6af95b67566bc76bb0f3ffc695f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#ac12dd6af95b67566bc76bb0f3ffc695f">UniqueElementPtr_t</a> = typename std::unique_ptr&lt; <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a>, stdext::inplace_function&lt; void(<a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a> *), 3 *sizeof(void *)&gt; &gt;</td></tr>
<tr class="memdesc:ac12dd6af95b67566bc76bb0f3ffc695f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for the unique pointer to the element We return functors to the client as a std::unique_ptr&lt;FuncOp&gt;.  <a href="#ac12dd6af95b67566bc76bb0f3ffc695f">More...</a><br /></td></tr>
<tr class="separator:ac12dd6af95b67566bc76bb0f3ffc695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbd3bb00d348605f66da53b8716ff8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a8fbd3bb00d348605f66da53b8716ff8a">ElementPtr_t</a> = <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a> *</td></tr>
<tr class="memdesc:a8fbd3bb00d348605f66da53b8716ff8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for our element.  <a href="#a8fbd3bb00d348605f66da53b8716ff8a">More...</a><br /></td></tr>
<tr class="separator:a8fbd3bb00d348605f66da53b8716ff8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cd05131471d3fee2a741298b462d9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#aa8cd05131471d3fee2a741298b462d9d">FuncOpStorage_t</a> = etl::queue&lt; <a class="el" href="../../d1/de1/group___function_queue.html#a8fbd3bb00d348605f66da53b8716ff8a">ElementPtr_t</a>, TQueueElements &gt;</td></tr>
<tr class="memdesc:aa8cd05131471d3fee2a741298b462d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the element storage queue.  <a href="#aa8cd05131471d3fee2a741298b462d9d">More...</a><br /></td></tr>
<tr class="separator:aa8cd05131471d3fee2a741298b462d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Member Functions</h3></td></tr>
<tr class="memitem:a0856bcf8afa066e9ff8483cc2bb1c0a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a0856bcf8afa066e9ff8483cc2bb1c0a1">deleter</a> (<a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a> *ptr)</td></tr>
<tr class="memdesc:a0856bcf8afa066e9ff8483cc2bb1c0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> objects to the memory pool.  <a href="#a0856bcf8afa066e9ff8483cc2bb1c0a1">More...</a><br /></td></tr>
<tr class="separator:a0856bcf8afa066e9ff8483cc2bb1c0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a1b958ae9a3c68f4ef56f8e15dc9411ae"><td class="memItemLeft" align="right" valign="top">etl::generic_pool&lt; TLargestSize, etl::largest&lt; <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a>, TFunc &gt;::alignment, TQueueElements &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a1b958ae9a3c68f4ef56f8e15dc9411ae">mem_pool_</a></td></tr>
<tr class="memdesc:a1b958ae9a3c68f4ef56f8e15dc9411ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory storage for FuncElement types We utilize a memory pool to allocate <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> objects for storage.  <a href="#a1b958ae9a3c68f4ef56f8e15dc9411ae">More...</a><br /></td></tr>
<tr class="separator:a1b958ae9a3c68f4ef56f8e15dc9411ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c3f1ecdc8f11c9e30ba1f0f3dccbb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/de1/group___function_queue.html#aa8cd05131471d3fee2a741298b462d9d">FuncOpStorage_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">queue_</a></td></tr>
<tr class="memdesc:a30c3f1ecdc8f11c9e30ba1f0f3dccbb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue which stores function objects.  <a href="#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">More...</a><br /></td></tr>
<tr class="separator:a30c3f1ecdc8f11c9e30ba1f0f3dccbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a8fbd3bb00d348605f66da53b8716ff8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbd3bb00d348605f66da53b8716ff8a">&#9670;&nbsp;</a></span>ElementPtr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#a8fbd3bb00d348605f66da53b8716ff8a">ElementPtr_t</a> =  <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a>*</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for our element. </p>
<p>We store pointers to <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> objects. </p>

</div>
</div>
<a id="aa8cd05131471d3fee2a741298b462d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8cd05131471d3fee2a741298b462d9d">&#9670;&nbsp;</a></span>FuncOpStorage_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#aa8cd05131471d3fee2a741298b462d9d">FuncOpStorage_t</a> =  etl::queue&lt;<a class="el" href="../../d1/de1/group___function_queue.html#a8fbd3bb00d348605f66da53b8716ff8a">ElementPtr_t</a>, TQueueElements&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for the element storage queue. </p>

</div>
</div>
<a id="ac12dd6af95b67566bc76bb0f3ffc695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12dd6af95b67566bc76bb0f3ffc695f">&#9670;&nbsp;</a></span>UniqueElementPtr_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#ac12dd6af95b67566bc76bb0f3ffc695f">UniqueElementPtr_t</a> =  typename std::unique_ptr&lt;<a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a>, stdext::inplace_function&lt;void(<a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a>*), 3 * sizeof(void*)&gt; &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience alias for the unique pointer to the element We return functors to the client as a std::unique_ptr&lt;FuncOp&gt;. </p>
<p>Memory is allocated from mem_pool_, so we use a deleter to ensure memory is recovered. </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a8cfa6ba49a9a0a0fe91f693f3f908628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfa6ba49a9a0a0fe91f693f3f908628">&#9670;&nbsp;</a></span>StaticFunctionQueue() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a0b13df6c931de0c13ee8e2cba65250b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b13df6c931de0c13ee8e2cba65250b7">&#9670;&nbsp;</a></span>~StaticFunctionQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::~<a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a id="a916445f6ecdb29df45e324ebd90a343b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916445f6ecdb29df45e324ebd90a343b">&#9670;&nbsp;</a></span>StaticFunctionQueue() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="a3f55595067039b31dd3bdfa9e7dfa48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f55595067039b31dd3bdfa9e7dfa48e">&#9670;&nbsp;</a></span>StaticFunctionQueue() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::<a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="acabcbbc32198cb967f1631b930ed9994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabcbbc32198cb967f1631b930ed9994">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the capacity in elements. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements that the queue can support. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

</div>
</div>
<a id="adb81165041ca746367e56f72be2f82ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb81165041ca746367e56f72be2f82ec">&#9670;&nbsp;</a></span>capacity_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::capacity_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the total memory consumed by this queue in bytes. </p>
<dl class="section return"><dt>Returns</dt><dd>the size of this function queue in bytes. </dd></dl>

</div>
</div>
<a id="a0856bcf8afa066e9ff8483cc2bb1c0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0856bcf8afa066e9ff8483cc2bb1c0a1">&#9670;&nbsp;</a></span>deleter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::deleter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> objects to the memory pool. </p>
<p>This deleter is used by with the std::unique_ptr that is used to store the function elements. When the <a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op" title="Base Class for storing functions.">FuncOp</a> object goes out of scope, its memory is automatically returned to the pool. </p>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a1b958ae9a3c68f4ef56f8e15dc9411ae">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::mem_pool_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::front()</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a74503bd66e5b25698437d1a9284c6187">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::popAndExec()</a>.</p>

</div>
</div>
<a id="a1ed8c5ecfc5bb180dc730c16b10d3830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed8c5ecfc5bb180dc730c16b10d3830">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the queue is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is empty, false otherwise. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a5aed6b1d605293891eac53ecff8c6dc5">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::size()</a>.</p>

</div>
</div>
<a id="a33b28387b888b42fdc78b3bdc8ba3744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b28387b888b42fdc78b3bdc8ba3744">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a copy of the functor at the front of the queue. </p>
<p>For efficient queue usage, clients will want to get the element from the front of the queue, call <a class="el" href="../../d1/de1/group___function_queue.html#a75df7f31f6e11c704fbac829eb45accd" title="Remove the element at the front of the queue.">pop()</a> to remove it from the queue, and then execute the function. This flow will ensure that the queue is not locked while the function is running (which happens with <a class="el" href="../../d1/de1/group___function_queue.html#a74503bd66e5b25698437d1a9284c6187" title="Remove the next functor from the front of the queue and execute it.">popAndExec()</a>).</p>
<dl class="section note"><dt>Note</dt><dd>Because we have a std::unique_ptr, <a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744" title="Get a copy of the functor at the front of the queue.">front()</a> can only be called once per functor.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744" title="Get a copy of the functor at the front of the queue.">front()</a> has not been previously called for this element. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a UniqueElementPtr_t to the functor at the front of the queue. Once the UniqueElementPtr_t goes out of scope, the function queue will recover the memory automatically. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a0856bcf8afa066e9ff8483cc2bb1c0a1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::deleter()</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

</div>
</div>
<a id="a01ecdbab120c73b703b53062ea6b99dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ecdbab120c73b703b53062ea6b99dc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a>&amp; <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a id="a98db410978a103ae7abac3fe4652dc5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98db410978a103ae7abac3fe4652dc5a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a>&amp; <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator. </p>

</div>
</div>
<a id="a75df7f31f6e11c704fbac829eb45accd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75df7f31f6e11c704fbac829eb45accd">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the element at the front of the queue. </p>
<dl class="section pre"><dt>Precondition</dt><dd>There is an element in the queue. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The element has been removed from the queue. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

</div>
</div>
<a id="a74503bd66e5b25698437d1a9284c6187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74503bd66e5b25698437d1a9284c6187">&#9670;&nbsp;</a></span>popAndExec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::popAndExec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the next functor from the front of the queue and execute it. </p>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a0856bcf8afa066e9ff8483cc2bb1c0a1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::deleter()</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

</div>
</div>
<a id="a9b240436c483ac6ebce1a99da3fa2716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b240436c483ac6ebce1a99da3fa2716">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const TFuncOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a function to the queue. </p>
<p>This function is noexcept because we want our program to abort if we are out of memory. Depending on the underlying queue type, it is certainly likely that there is throw support.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFuncOp</td><td>The type of the functor to add to the queue. This template parameter is automatically deduced by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The functor object to add to the queue. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d1/da3/include_2assert_8h.html#af576bf8ffa22a44e53018c67095ffbf0">assert</a>, <a class="el" href="../../d1/de1/group___function_queue.html#a1b958ae9a3c68f4ef56f8e15dc9411ae">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::mem_pool_</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

</div>
</div>
<a id="ad8fd8921dda6d1285377426a603a3d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fd8921dda6d1285377426a603a3d6b">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename TFuncOp &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::push </td>
          <td>(</td>
          <td class="paramtype">TFuncOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

<p class="reference">References <a class="el" href="../../d1/da3/include_2assert_8h.html#af576bf8ffa22a44e53018c67095ffbf0">assert</a>, <a class="el" href="../../d1/de1/group___function_queue.html#a1b958ae9a3c68f4ef56f8e15dc9411ae">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::mem_pool_</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

</div>
</div>
<a id="a5aed6b1d605293891eac53ecff8c6dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aed6b1d605293891eac53ecff8c6dc5">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the current number of elements in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements currently stored in the queue. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/de1/group___function_queue.html#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/de1/group___function_queue.html#a1ed8c5ecfc5bb180dc730c16b10d3830">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::empty()</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a1b958ae9a3c68f4ef56f8e15dc9411ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b958ae9a3c68f4ef56f8e15dc9411ae">&#9670;&nbsp;</a></span>mem_pool_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">etl::generic_pool&lt;TLargestSize, etl::largest&lt;<a class="el" href="../../d1/de1/group___function_queue.html#d6/d41/classembutil_1_1_func_op">FuncOp</a>, TFunc&gt;::alignment, TQueueElements&gt; <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::mem_pool_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory storage for FuncElement types We utilize a memory pool to allocate <a class="el" href="../../d1/de1/group___function_queue.html#dd/d91/classembutil_1_1_func_op_bound" title="Represents a bound function object.">FuncOpBound</a> objects for storage. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/de1/group___function_queue.html#a0856bcf8afa066e9ff8483cc2bb1c0a1">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::deleter()</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a9b240436c483ac6ebce1a99da3fa2716">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::push()</a>.</p>

</div>
</div>
<a id="a30c3f1ecdc8f11c9e30ba1f0f3dccbb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c3f1ecdc8f11c9e30ba1f0f3dccbb1">&#9670;&nbsp;</a></span>queue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TQueueElements, const size_t TLargestSize = DefaultStaticQueueLargestSize, typename TFunc  = stdext::inplace_function&lt;void()&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de1/group___function_queue.html#aa8cd05131471d3fee2a741298b462d9d">FuncOpStorage_t</a> <a class="el" href="../../d1/de1/group___function_queue.html#db/d7b/classembutil_1_1_static_function_queue">embutil::StaticFunctionQueue</a>&lt; TQueueElements, TLargestSize, TFunc &gt;::queue_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Queue which stores function objects. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/de1/group___function_queue.html#acabcbbc32198cb967f1631b930ed9994">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::capacity()</a>, <a class="el" href="../../d1/de1/group___function_queue.html#a33b28387b888b42fdc78b3bdc8ba3744">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::front()</a>, <a class="el" href="../../d1/de1/group___function_queue.html#a75df7f31f6e11c704fbac829eb45accd">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::pop()</a>, <a class="el" href="../../d1/de1/group___function_queue.html#a74503bd66e5b25698437d1a9284c6187">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::popAndExec()</a>, <a class="el" href="../../d1/de1/group___function_queue.html#a9b240436c483ac6ebce1a99da3fa2716">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::push()</a>, and <a class="el" href="../../d1/de1/group___function_queue.html#a5aed6b1d605293891eac53ecff8c6dc5">embutil::StaticFunctionQueue&lt; TQueueElements, TLargestSize, TFunc &gt;::size()</a>.</p>

</div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
