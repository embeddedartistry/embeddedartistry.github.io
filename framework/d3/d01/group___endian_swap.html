<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry Framework: Endian Swap</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Artistry Framework
   </div>
   <div id="projectbrief">Embedded Systems C++ Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Endian Swap<div class="ingroups"><a class="el" href="../../d3/dd5/group___framework_utils.html">Framework Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions that can be used to swap the endianness of a value.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Endian Swap:</div>
<div class="dyncontent">
<center><table><tr><td><img src="../../d3/d01/group___endian_swap.jpg" border="0" alt="" usemap="#d3_2d01_2group______endian__swap"/>
<map name="d3_2d01_2group______endian__swap" id="d3_2d01_2group______endian__swap">
<area shape="rect"  href="../../d3/dd5/group___framework_utils.html" title="Embedded Framework utility classes and functions." alt="" coords="5,5,140,29"/>
<area shape="rect"  title="Functions that can be used to swap the endianness of a value." alt="" coords="188,5,288,29"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5998b48f8bbef877fb0bdd85ab92e495"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga5998b48f8bbef877fb0bdd85ab92e495"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::enable_if&lt; std::is_unsigned&lt; <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &gt;::value, <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d01/group___endian_swap.html#ga5998b48f8bbef877fb0bdd85ab92e495">embutil::byteswap</a> (<a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> i, <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> j=0u, std::size_t n=0u)</td></tr>
<tr class="memdesc:ga5998b48f8bbef877fb0bdd85ab92e495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive constexpr byteswap implementation without C++17 fold expressions.  <a href="../../d3/d01/group___endian_swap.html#ga5998b48f8bbef877fb0bdd85ab92e495">More...</a><br /></td></tr>
<tr class="separator:ga5998b48f8bbef877fb0bdd85ab92e495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02823ecc1daf9c9fa03fd9890d041e46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga02823ecc1daf9c9fa03fd9890d041e46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d01/group___endian_swap.html#ga02823ecc1daf9c9fa03fd9890d041e46">embutil::SwapEndian</a> (<a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &amp;val, typename std::enable_if&lt; std::is_arithmetic&lt; <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &gt;::value, std::nullptr_t &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a> unused=nullptr)</td></tr>
<tr class="memdesc:ga02823ecc1daf9c9fa03fd9890d041e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-constexpr Robust Endian Swap.  <a href="../../d3/d01/group___endian_swap.html#ga02823ecc1daf9c9fa03fd9890d041e46">More...</a><br /></td></tr>
<tr class="separator:ga02823ecc1daf9c9fa03fd9890d041e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b11ee2f19613b7f94dcf500fd1e455b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2b11ee2f19613b7f94dcf500fd1e455b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d01/group___endian_swap.html#ga2b11ee2f19613b7f94dcf500fd1e455b">embutil::SwapEndian_UB</a> (<a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &amp;val)</td></tr>
<tr class="memdesc:ga2b11ee2f19613b7f94dcf500fd1e455b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endian swap using undefined behavior.  <a href="../../d3/d01/group___endian_swap.html#ga2b11ee2f19613b7f94dcf500fd1e455b">More...</a><br /></td></tr>
<tr class="separator:ga2b11ee2f19613b7f94dcf500fd1e455b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Functions that can be used to swap the endianness of a value. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5998b48f8bbef877fb0bdd85ab92e495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5998b48f8bbef877fb0bdd85ab92e495">&#9670;&nbsp;</a></span>byteswap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::enable_if&lt;std::is_unsigned&lt;<a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>&gt;::value, <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>&gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a> embutil::byteswap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>&#160;</td>
          <td class="paramname"><em>j</em> = <code>0u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/dbb/x86__64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">std::size_t</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>0u</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursive constexpr byteswap implementation without C++17 fold expressions. </p>
<p>Specialized implementations can be defined for specific types if desired. Example of template specialization for a specific type:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="keywordtype">void</span> SwapEndian&lt;std::uint32_t&gt;(<a class="code" href="../../df/d92/aarch64_2include_2__types_2__uint32__t_8h.html#a435d1572bf3f880d55459d9805097f62">std::uint32_t</a> &amp;value) {</div><div class="line">    <a class="code" href="../../df/d92/aarch64_2include_2__types_2__uint32__t_8h.html#a435d1572bf3f880d55459d9805097f62">std::uint32_t</a> tmp = ((value &lt;&lt; 8) &amp; 0xFF00FF00) | ((value &gt;&gt; 8) &amp; 0xFF00FF);</div><div class="line">    value = (tmp &lt;&lt; 16) | (tmp &gt;&gt; 16);</div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value being byteswap'd. This is (typically) deduced by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The value to byteswap. </td></tr>
    <tr><td class="paramname">j</td><td>Used in the recursive calculation; users should not set this. </td></tr>
    <tr><td class="paramname">n</td><td>Used in the recursive calculation; users shoudl not set this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endian swapped value. </dd></dl>

<p class="reference">References <a class="el" href="../../d9/d86/limits_8h.html#a308d9dd2c0028ddb184b455bbd7865de">CHAR_BIT</a>, <a class="el" href="../../d0/d40/test_2stdlib_2heapsort_8c.html#a4ee32b092e68c7a43abb455e5c146695">n</a>, and <a class="el" href="../../d3/d0d/k__tan_8c.html#a0acb682b8260ab1c60b918599864e2e5">T</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../de/d39/group___framework_drivers.html#ad206df2e2ee71707fec11bf839bdd08e">embdrv::vl53l1x::readTrim()</a>, and <a class="el" href="../../de/d39/group___framework_drivers.html#a7b53deef15d36f2f23f03b2c552a4277">embdrv::vl53l1x::writeReg()</a>.</p>

</div>
</div>
<a id="ga02823ecc1daf9c9fa03fd9890d041e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02823ecc1daf9c9fa03fd9890d041e46">&#9670;&nbsp;</a></span>SwapEndian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embutil::SwapEndian </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt; std::is_arithmetic&lt; <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &gt;::value, std::nullptr_t &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a>&#160;</td>
          <td class="paramname"><em>unused</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-constexpr Robust Endian Swap. </p>
<p>Described here: <a href="https://mklimenko.github.io/english/2018/08/22/robust-endian-swap/">https://mklimenko.github.io/english/2018/08/22/robust-endian-swap/</a> This approach avoids bitmasks/shifts and intrinsics, which can be non-portable and error prone</p>
<p>The idea is simple: we define a template function, in which there is a union, containing both the passed value and the std::array of the corresponding size. We create two objects of such union and perform the reverse copying from one to another. All the extra assignments will be optimized out by the compiler, which will make this code fast and efficient.</p>
<p>We use the SFINAE-d version to make sure you won’t pass anything wrong</p>
<p>The good thing about this is that we have a template for all the corner cases and possible types. But the greatest is that the compiler was able to optimize both of these functions into one assembly command bswap. Some instructions sets haven’t got that command and if this will become the bottleneck of your program, you can make a template specialization for the case you need.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of integer to perform the swap on. This value is (typically) deduced by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to perform an endian swap on. </td></tr>
    <tr><td class="paramname">unused</td><td>An unused parameter, present for use with std::enable_if. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d0d/k__tan_8c.html#a0acb682b8260ab1c60b918599864e2e5">T</a>.</p>

</div>
</div>
<a id="ga2b11ee2f19613b7f94dcf500fd1e455b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b11ee2f19613b7f94dcf500fd1e455b">&#9670;&nbsp;</a></span>SwapEndian_UB()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void embutil::SwapEndian_UB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endian swap using undefined behavior. </p>
<p>Original version of <a class="el" href="../../d3/d01/group___endian_swap.html#ga02823ecc1daf9c9fa03fd9890d041e46" title="Non-constexpr Robust Endian Swap.">SwapEndian()</a>. The undefined behavior is due to the use of an inactive member of the union. This function is efficient, but the undefined behavior makes it risky.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of integer to perform the swap on. This value is (typically) deduced by the compiler. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to perform an endian swpa on. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d3/d0d/k__tan_8c.html#a0acb682b8260ab1c60b918599864e2e5">T</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
