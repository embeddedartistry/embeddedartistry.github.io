<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry Framework: embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Artistry Framework
   </div>
   <div id="projectbrief">Embedded Systems C++ Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dc/dda/namespaceembvm.html">embvm</a></li><li class="navelem"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html">spi</a></li><li class="navelem"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">activeMaster</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="../../d9/d68/classembvm_1_1spi_1_1active_master-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;active_spi.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../de/dca/classembvm_1_1spi_1_1active_master__inherit__graph.jpg" border="0" usemap="#embvm_1_1spi_1_1active_master_3_01_t_queue_size_00_01_t_lock_00_01_t_cond_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="embvm_1_1spi_1_1active_master_3_01_t_queue_size_00_01_t_lock_00_01_t_cond_01_4_inherit__map" id="embvm_1_1spi_1_1active_master_3_01_t_queue_size_00_01_t_lock_00_01_t_cond_01_4_inherit__map">
<area shape="rect"  title=" " alt="" coords="206,796,415,1003"/>
<area shape="rect"  href="../../d4/da2/classembvm_1_1spi_1_1master.html" title="This class provides the SPI master interface definition." alt="" coords="146,433,283,747"/>
<area shape="rect"  href="../../d1/dc2/group___framework_driver.html#d8/d47/classembvm_1_1_driver_base" title="Virtual base class for framework drivers." alt="" coords="5,5,144,332"/>
<area shape="rect"  title=" " alt="" coords="167,132,272,205"/>
<area shape="rect"  href="../../d0/da7/classembutil_1_1active_object.html" title=" " alt="" coords="307,473,508,707"/>
<area shape="rect"  href="../../d0/da7/classembutil_1_1active_object.html" title=" " alt="" coords="301,65,515,272"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adabbeef822dbc7a9f2cf0893ec97a383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#adabbeef822dbc7a9f2cf0893ec97a383">activeMaster</a> (<a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html">embvm::spi::master</a> &amp;m) noexcept</td></tr>
<tr class="separator:adabbeef822dbc7a9f2cf0893ec97a383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a79df7c2ac1006c1610f59f27ae0740"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a2a79df7c2ac1006c1610f59f27ae0740">~activeMaster</a> ()=default</td></tr>
<tr class="separator:a2a79df7c2ac1006c1610f59f27ae0740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b9c108c1157086cbb627960176678f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a60b9c108c1157086cbb627960176678f">process_</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">ao_storage</a> pair) noexcept</td></tr>
<tr class="separator:a60b9c108c1157086cbb627960176678f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308e5fdc5c4ae83fb64682dc0c6aa67b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a308e5fdc5c4ae83fb64682dc0c6aa67b">configure</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#ab7cd3d885f29264b8269fafa95690d80">spi::baud_t</a> baud) noexcept</td></tr>
<tr class="memdesc:a308e5fdc5c4ae83fb64682dc0c6aa67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the SPI bus.  <a href="#a308e5fdc5c4ae83fb64682dc0c6aa67b">More...</a><br /></td></tr>
<tr class="separator:a308e5fdc5c4ae83fb64682dc0c6aa67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af850a9b2a8aae19bc06845257ff200ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af850a9b2a8aae19bc06845257ff200ca">mode</a> () const noexcept</td></tr>
<tr class="memdesc:af850a9b2a8aae19bc06845257ff200ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current SPI bus mode.  <a href="#af850a9b2a8aae19bc06845257ff200ca">More...</a><br /></td></tr>
<tr class="separator:af850a9b2a8aae19bc06845257ff200ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9b0e6e31c2e6730379b8c4ac8f5747"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a5d9b0e6e31c2e6730379b8c4ac8f5747">mode</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a> <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">mode</a>) noexcept</td></tr>
<tr class="memdesc:a5d9b0e6e31c2e6730379b8c4ac8f5747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SPI bus mode.  <a href="#a5d9b0e6e31c2e6730379b8c4ac8f5747">More...</a><br /></td></tr>
<tr class="separator:a5d9b0e6e31c2e6730379b8c4ac8f5747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756305bf86484e2ddcf3398aa16ac6e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a756305bf86484e2ddcf3398aa16ac6e6">order</a> () const noexcept</td></tr>
<tr class="memdesc:a756305bf86484e2ddcf3398aa16ac6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current SPI bus byte order.  <a href="#a756305bf86484e2ddcf3398aa16ac6e6">More...</a><br /></td></tr>
<tr class="separator:a756305bf86484e2ddcf3398aa16ac6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62bd88b8683d12187d1c8ca815f4655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af62bd88b8683d12187d1c8ca815f4655">order</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a> <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">order</a>) noexcept</td></tr>
<tr class="memdesc:af62bd88b8683d12187d1c8ca815f4655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SPI bus byte order.  <a href="#af62bd88b8683d12187d1c8ca815f4655">More...</a><br /></td></tr>
<tr class="separator:af62bd88b8683d12187d1c8ca815f4655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa287e02a3ec4fbd9e97508c4c9fb8f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#aaa287e02a3ec4fbd9e97508c4c9fb8f9">start</a> () noexcept</td></tr>
<tr class="memdesc:aaa287e02a3ec4fbd9e97508c4c9fb8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the driver.  <a href="#aaa287e02a3ec4fbd9e97508c4c9fb8f9">More...</a><br /></td></tr>
<tr class="separator:aaa287e02a3ec4fbd9e97508c4c9fb8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaebcecbe8194c8e644cfa1a579c808c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#adaebcecbe8194c8e644cfa1a579c808c">stop</a> () noexcept</td></tr>
<tr class="memdesc:adaebcecbe8194c8e644cfa1a579c808c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the driver.  <a href="#adaebcecbe8194c8e644cfa1a579c808c">More...</a><br /></td></tr>
<tr class="separator:adaebcecbe8194c8e644cfa1a579c808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ef4047fa20ec89cdaf4663f61bedd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#af5ef4047fa20ec89cdaf4663f61bedd9">restart</a> () noexcept</td></tr>
<tr class="memdesc:af5ef4047fa20ec89cdaf4663f61bedd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restart the driver.  <a href="#af5ef4047fa20ec89cdaf4663f61bedd9">More...</a><br /></td></tr>
<tr class="separator:af5ef4047fa20ec89cdaf4663f61bedd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01670f19d5b777d92139ff80523c1f4c"><td class="memItemLeft" align="right" valign="top">type_safe::boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#a01670f19d5b777d92139ff80523c1f4c">started</a> () const noexcept</td></tr>
<tr class="memdesc:a01670f19d5b777d92139ff80523c1f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the driver has been started.  <a href="#a01670f19d5b777d92139ff80523c1f4c">More...</a><br /></td></tr>
<tr class="separator:a01670f19d5b777d92139ff80523c1f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589a09f7583ca866df9f7357d162f2be"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="../../d1/dc2/group___framework_driver.html#gab080d1ffd9eaaddfe5cc7f59df79b915">embvm::DriverType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#a589a09f7583ca866df9f7357d162f2be">DriverType</a> () const noexcept</td></tr>
<tr class="memdesc:a589a09f7583ca866df9f7357d162f2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the registered type ID of the driver.  <a href="#a589a09f7583ca866df9f7357d162f2be">More...</a><br /></td></tr>
<tr class="separator:a589a09f7583ca866df9f7357d162f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860062cec176fd6d0f27c3444005524"><td class="memItemLeft" align="right" valign="top">constexpr const std::string_view &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#ae860062cec176fd6d0f27c3444005524">name</a> () const noexcept</td></tr>
<tr class="memdesc:ae860062cec176fd6d0f27c3444005524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a string_view reference of the driver name.  <a href="#ae860062cec176fd6d0f27c3444005524">More...</a><br /></td></tr>
<tr class="separator:ae860062cec176fd6d0f27c3444005524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0238f8ee997b79a1678bea9cb6154fd"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#ad0238f8ee997b79a1678bea9cb6154fd">name_cstr</a> () const noexcept</td></tr>
<tr class="memdesc:ad0238f8ee997b79a1678bea9cb6154fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a c-string version of the driver name.  <a href="#ad0238f8ee997b79a1678bea9cb6154fd">More...</a><br /></td></tr>
<tr class="separator:ad0238f8ee997b79a1678bea9cb6154fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0ad7aa87480bbae78bb030134cedf0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d1/dc2/group___framework_driver.html#d8/d47/classembvm_1_1_driver_base">DriverBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#a8c0ad7aa87480bbae78bb030134cedf0">operator++</a> () noexcept</td></tr>
<tr class="memdesc:a8c0ad7aa87480bbae78bb030134cedf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment operator is a no-op, but is used for iterator compatibility.  <a href="#a8c0ad7aa87480bbae78bb030134cedf0">More...</a><br /></td></tr>
<tr class="separator:a8c0ad7aa87480bbae78bb030134cedf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74663ed700c8c5b1bd31a90cee46f80a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da7/classembutil_1_1active_object.html#a74663ed700c8c5b1bd31a90cee46f80a">queuedCount</a> () const noexcept</td></tr>
<tr class="memdesc:a74663ed700c8c5b1bd31a90cee46f80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of operations in the queue.  <a href="#a74663ed700c8c5b1bd31a90cee46f80a">More...</a><br /></td></tr>
<tr class="separator:a74663ed700c8c5b1bd31a90cee46f80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5d2316c316a6dc6d78f28a96eef47f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da7/classembutil_1_1active_object.html#a8c5d2316c316a6dc6d78f28a96eef47f">enqueue</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">embvm::spi::ao_storage</a> <a class="el" href="../../de/d74/test_2stdlib_2strtof_8c.html#a4bd67e987dfc9e09afd79a2c863b5af3">t</a>) noexcept</td></tr>
<tr class="memdesc:a8c5d2316c316a6dc6d78f28a96eef47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an operation to the queue.  <a href="#a8c5d2316c316a6dc6d78f28a96eef47f">More...</a><br /></td></tr>
<tr class="separator:a8c5d2316c316a6dc6d78f28a96eef47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebe65c68a084a00920582bd2140a458"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da7/classembutil_1_1active_object.html#a1ebe65c68a084a00920582bd2140a458">shutdown</a> () noexcept</td></tr>
<tr class="memdesc:a1ebe65c68a084a00920582bd2140a458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the active object.  <a href="#a1ebe65c68a084a00920582bd2140a458">More...</a><br /></td></tr>
<tr class="separator:a1ebe65c68a084a00920582bd2140a458"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4a0e4c36efdcc841ef5491ccf5f18b26"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="../../d1/dc2/group___framework_driver.html#ga92dffcfd32d2dee7a13ab04beb3f4b33">embvm::DriverType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a4a0e4c36efdcc841ef5491ccf5f18b26">type</a> () noexcept</td></tr>
<tr class="memdesc:a4a0e4c36efdcc841ef5491ccf5f18b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Driver Type ID.  <a href="#a4a0e4c36efdcc841ef5491ccf5f18b26">More...</a><br /></td></tr>
<tr class="separator:a4a0e4c36efdcc841ef5491ccf5f18b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af43bc466c185cf3d79f3b715ce00559b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d19/namespaceembvm_1_1comm.html#ab1bb117426da7307c65bf9b7e782a901">embvm::comm::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af43bc466c185cf3d79f3b715ce00559b">transfer_</a> (const <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#d5/d30/structembvm_1_1spi_1_1op__t">spi::op_t</a> &amp;op, const cb_t &amp;cb) noexcept override=0</td></tr>
<tr class="separator:af43bc466c185cf3d79f3b715ce00559b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a07d12d6819071802957b949ff5b9a4ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a07d12d6819071802957b949ff5b9a4ad">mode_</a> = <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05ab4f91f3e8dc5079cab466793ebf3d0cf">spi::mode::mode0</a></td></tr>
<tr class="memdesc:a07d12d6819071802957b949ff5b9a4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the active SPI mode configuration.  <a href="#a07d12d6819071802957b949ff5b9a4ad">More...</a><br /></td></tr>
<tr class="separator:a07d12d6819071802957b949ff5b9a4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89626dd7c12eae0a5901f0151a6e4981"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a89626dd7c12eae0a5901f0151a6e4981">order_</a> = <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdeaa82a53f458a5666053e97da7b866d8922">spi::order::msbFirst</a></td></tr>
<tr class="memdesc:a89626dd7c12eae0a5901f0151a6e4981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the active SPI byte ordering.  <a href="#a89626dd7c12eae0a5901f0151a6e4981">More...</a><br /></td></tr>
<tr class="separator:a89626dd7c12eae0a5901f0151a6e4981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d296e5ae7c65ea7d6faf57c0386a8"><td class="memItemLeft" align="right" valign="top">type_safe::boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#a403d296e5ae7c65ea7d6faf57c0386a8">started_</a> = <a class="el" href="../../dc/d6c/test__suite_8cpp.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a403d296e5ae7c65ea7d6faf57c0386a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tracks the driver state.  <a href="#a403d296e5ae7c65ea7d6faf57c0386a8">More...</a><br /></td></tr>
<tr class="separator:a403d296e5ae7c65ea7d6faf57c0386a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea20098162d8ad9d7732ef409ef3e68"><td class="memItemLeft" align="right" valign="top">const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#abea20098162d8ad9d7732ef409ef3e68">name_</a></td></tr>
<tr class="memdesc:abea20098162d8ad9d7732ef409ef3e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the driver instance.  <a href="#abea20098162d8ad9d7732ef409ef3e68">More...</a><br /></td></tr>
<tr class="separator:abea20098162d8ad9d7732ef409ef3e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbce4c3b40f00a6a88db890b24e362b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d1/dc2/group___framework_driver.html#gab080d1ffd9eaaddfe5cc7f59df79b915">embvm::DriverType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc2/group___framework_driver.html#abbce4c3b40f00a6a88db890b24e362b2">type_</a></td></tr>
<tr class="memdesc:abbce4c3b40f00a6a88db890b24e362b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type ID of the driver instance.  <a href="#abbce4c3b40f00a6a88db890b24e362b2">More...</a><br /></td></tr>
<tr class="separator:abbce4c3b40f00a6a88db890b24e362b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aa0da176883deb64f467f8a9bb759e8f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#aa0da176883deb64f467f8a9bb759e8f0">ao_base</a> = <a class="el" href="../../d0/da7/classembutil_1_1active_object.html">embutil::activeObject</a>&lt; <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">activeMaster</a>, <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">ao_storage</a>, TQueueSize, TLock, TCond &gt;</td></tr>
<tr class="separator:aa0da176883deb64f467f8a9bb759e8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a44b91f29cebaf6d3778462978c46e70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a44b91f29cebaf6d3778462978c46e70c">start_</a> () noexcept final</td></tr>
<tr class="memdesc:a44b91f29cebaf6d3778462978c46e70c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes override the start_ method to control driver-specific startup behavior.  <a href="#a44b91f29cebaf6d3778462978c46e70c">More...</a><br /></td></tr>
<tr class="separator:a44b91f29cebaf6d3778462978c46e70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2a66c260ceb8d262ea1ee2ea42d718"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a3c2a66c260ceb8d262ea1ee2ea42d718">stop_</a> () noexcept final</td></tr>
<tr class="memdesc:a3c2a66c260ceb8d262ea1ee2ea42d718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Derived classes override the start_ method to control driver-specific startup behavior.  <a href="#a3c2a66c260ceb8d262ea1ee2ea42d718">More...</a><br /></td></tr>
<tr class="separator:a3c2a66c260ceb8d262ea1ee2ea42d718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462d183a332b9f18571b1867ad2a72a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a462d183a332b9f18571b1867ad2a72a1">configure_</a> () noexcept final</td></tr>
<tr class="memdesc:a462d183a332b9f18571b1867ad2a72a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the SPI bus for operation.  <a href="#a462d183a332b9f18571b1867ad2a72a1">More...</a><br /></td></tr>
<tr class="separator:a462d183a332b9f18571b1867ad2a72a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8654a10388a3566b09a37088d434394c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a8654a10388a3566b09a37088d434394c">setMode_</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">embvm::spi::mode</a> <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">mode</a>) noexcept final</td></tr>
<tr class="memdesc:a8654a10388a3566b09a37088d434394c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SPI bus mode.  <a href="#a8654a10388a3566b09a37088d434394c">More...</a><br /></td></tr>
<tr class="separator:a8654a10388a3566b09a37088d434394c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c7751c2c00b8aecdf908b63021df1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a751c7751c2c00b8aecdf908b63021df1">setOrder_</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">embvm::spi::order</a> <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">order</a>) noexcept final</td></tr>
<tr class="memdesc:a751c7751c2c00b8aecdf908b63021df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the SPI bus byte order.  <a href="#a751c7751c2c00b8aecdf908b63021df1">More...</a><br /></td></tr>
<tr class="separator:a751c7751c2c00b8aecdf908b63021df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fbff3a41f758a69f08f77b2d56608a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d19/namespaceembvm_1_1comm.html#ab1bb117426da7307c65bf9b7e782a901">embvm::spi::status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a69fbff3a41f758a69f08f77b2d56608a">transfer_</a> (const <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#d5/d30/structembvm_1_1spi_1_1op__t">embvm::spi::op_t</a> &amp;op, const embvm::spi::master::cb_t &amp;cb) noexcept final</td></tr>
<tr class="separator:a69fbff3a41f758a69f08f77b2d56608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3596c2f3e30606b07b2dd474cc0a21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#ab7cd3d885f29264b8269fafa95690d80">embvm::spi::baud_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#aab3596c2f3e30606b07b2dd474cc0a21">baudrate_</a> (<a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#ab7cd3d885f29264b8269fafa95690d80">embvm::spi::baud_t</a> baud) noexcept final</td></tr>
<tr class="separator:aab3596c2f3e30606b07b2dd474cc0a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a0a3d7e06bbec9b558c405d7d40c7a042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html">embvm::spi::master</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">m_</a></td></tr>
<tr class="separator:a0a3d7e06bbec9b558c405d7d40c7a042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa0da176883deb64f467f8a9bb759e8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0da176883deb64f467f8a9bb759e8f0">&#9670;&nbsp;</a></span>ao_base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::<a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#aa0da176883deb64f467f8a9bb759e8f0">ao_base</a> =  <a class="el" href="../../d0/da7/classembutil_1_1active_object.html">embutil::activeObject</a>&lt;<a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">activeMaster</a>, <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">ao_storage</a>, TQueueSize, TLock, TCond&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adabbeef822dbc7a9f2cf0893ec97a383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adabbeef822dbc7a9f2cf0893ec97a383">&#9670;&nbsp;</a></span>activeMaster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::<a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">activeMaster</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html">embvm::spi::master</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a79df7c2ac1006c1610f59f27ae0740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a79df7c2ac1006c1610f59f27ae0740">&#9670;&nbsp;</a></span>~activeMaster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::~<a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">activeMaster</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aab3596c2f3e30606b07b2dd474cc0a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3596c2f3e30606b07b2dd474cc0a21">&#9670;&nbsp;</a></span>baudrate_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#ab7cd3d885f29264b8269fafa95690d80">embvm::spi::baud_t</a> <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::baudrate_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#ab7cd3d885f29264b8269fafa95690d80">embvm::spi::baud_t</a>&#160;</td>
          <td class="paramname"><em>baud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#aebc4566c4ceedce86577983d310a48df">embvm::spi::master</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::m_</a>.</p>

</div>
</div>
<a id="a308e5fdc5c4ae83fb64682dc0c6aa67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308e5fdc5c4ae83fb64682dc0c6aa67b">&#9670;&nbsp;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void embvm::spi::master::configure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#ab7cd3d885f29264b8269fafa95690d80">spi::baud_t</a>&#160;</td>
          <td class="paramname"><em>baud</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the SPI bus. </p>
<p>Configures the SPI bus for operation and sets the target baud rate.</p>
<p>Derived classes must implement the <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a462d183a332b9f18571b1867ad2a72a1" title="Configure the SPI bus for operation.">configure_()</a> function to set up the target hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baud</td><td>The target baudrate, in Hz. TODO: Tolerance - allowed relative tolerance for the resulting baudrate </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a391111fab7f0401dcb2ce4a2e101d0e5">embvm::spi::master::configure_()</a>.</p>

</div>
</div>
<a id="a462d183a332b9f18571b1867ad2a72a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462d183a332b9f18571b1867ad2a72a1">&#9670;&nbsp;</a></span>configure_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::configure_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Configure the SPI bus for operation. </p>
<p>This function is implemented by the derived class. It is responsible for configuring the target hardware for operation. </p>

<p>Implements <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a391111fab7f0401dcb2ce4a2e101d0e5">embvm::spi::master</a>.</p>

</div>
</div>
<a id="a589a09f7583ca866df9f7357d162f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589a09f7583ca866df9f7357d162f2be">&#9670;&nbsp;</a></span>DriverType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="../../d1/dc2/group___framework_driver.html#gab080d1ffd9eaaddfe5cc7f59df79b915">embvm::DriverType_t</a> embvm::DriverBase::DriverType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the registered type ID of the driver. </p>
<p>When using <a class="el" href="../../d1/dc2/group___framework_driver.html#d8/d47/classembvm_1_1_driver_base" title="Virtual base class for framework drivers.">DriverBase</a> interfaces, clients can retrieve the registered driver type in order to up-cast to the correct interface.</p>
<p>The type is returned as a <a class="el" href="../../d1/dc2/group___framework_driver.html#gab080d1ffd9eaaddfe5cc7f59df79b915" title="Driver type used by framework interfaces.">embvm::DriverType_t</a> rather than a <a class="el" href="../../d1/dc2/group___framework_driver.html#ga92dffcfd32d2dee7a13ab04beb3f4b33" title="Default framework driver type definitions.">embvm::DriverType</a> enum to work with custom user-defined types. Enforcing a <a class="el" href="../../d1/dc2/group___framework_driver.html#ga92dffcfd32d2dee7a13ab04beb3f4b33" title="Default framework driver type definitions.">embvm::DriverType</a> return value would prevent clients from defining and using their own custom types.</p>
<dl class="section return"><dt>Returns</dt><dd>the registered driver type as a <a class="el" href="../../d1/dc2/group___framework_driver.html#gab080d1ffd9eaaddfe5cc7f59df79b915" title="Driver type used by framework interfaces.">embvm::DriverType_t</a> value </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#abbce4c3b40f00a6a88db890b24e362b2">embvm::DriverBase::type_</a>.</p>

</div>
</div>
<a id="a8c5d2316c316a6dc6d78f28a96eef47f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5d2316c316a6dc6d78f28a96eef47f">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> <a class="el" href="../../d0/da7/classembutil_1_1active_object.html">embutil::activeObject</a>&lt; <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt; , <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">embvm::spi::ao_storage</a> , TQueueSize, TLock, TCond &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">embvm::spi::ao_storage</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an operation to the queue. </p>
<p>This function can be called directly, or by functions internal to the activeObject. For example, the "transfer" API enqueues transfer operations.</p>
<p>This function is marked noexcept because we want the program to terminate if an exception results from this call. For example, the underlying queue may throw on push.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The operation data object to enqueue for later processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af850a9b2a8aae19bc06845257ff200ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af850a9b2a8aae19bc06845257ff200ca">&#9670;&nbsp;</a></span>mode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a> embvm::spi::master::mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current SPI bus mode. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured mode. </dd></dl>

<p class="reference">References <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a07d12d6819071802957b949ff5b9a4ad">embvm::spi::master::mode_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a5d9b0e6e31c2e6730379b8c4ac8f5747">embvm::spi::master::mode()</a>, and <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a8654a10388a3566b09a37088d434394c">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::setMode_()</a>.</p>

</div>
</div>
<a id="a5d9b0e6e31c2e6730379b8c4ac8f5747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9b0e6e31c2e6730379b8c4ac8f5747">&#9670;&nbsp;</a></span>mode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a> embvm::spi::master::mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the SPI bus mode. </p>
<p>Derived classes must implement the <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a8654a10388a3566b09a37088d434394c" title="Set the SPI bus mode.">setMode_()</a> function, which is reponsible for configuring the target hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired SPI bus mode. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new SPI bus mode. </dd></dl>

<p class="reference">References <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af850a9b2a8aae19bc06845257ff200ca">embvm::spi::master::mode()</a>, <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a07d12d6819071802957b949ff5b9a4ad">embvm::spi::master::mode_</a>, and <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a3441d494e27c53c453288009048a2bcd">embvm::spi::master::setMode_()</a>.</p>

</div>
</div>
<a id="ae860062cec176fd6d0f27c3444005524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae860062cec176fd6d0f27c3444005524">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::string_view&amp; embvm::DriverBase::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a string_view reference of the driver name. </p>
<dl class="section return"><dt>Returns</dt><dd><code>std::string_view</code> ref containing the driver name. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#abea20098162d8ad9d7732ef409ef3e68">embvm::DriverBase::name_</a>.</p>

</div>
</div>
<a id="ad0238f8ee997b79a1678bea9cb6154fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0238f8ee997b79a1678bea9cb6154fd">&#9670;&nbsp;</a></span>name_cstr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* embvm::DriverBase::name_cstr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a c-string version of the driver name. </p>
<dl class="section return"><dt>Returns</dt><dd>c-string containing the driver name </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#abea20098162d8ad9d7732ef409ef3e68">embvm::DriverBase::name_</a>.</p>

</div>
</div>
<a id="a8c0ad7aa87480bbae78bb030134cedf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0ad7aa87480bbae78bb030134cedf0">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d1/dc2/group___framework_driver.html#d8/d47/classembvm_1_1_driver_base">DriverBase</a>&amp; embvm::DriverBase::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment operator is a no-op, but is used for iterator compatibility. </p>

</div>
</div>
<a id="a756305bf86484e2ddcf3398aa16ac6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756305bf86484e2ddcf3398aa16ac6e6">&#9670;&nbsp;</a></span>order() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a> embvm::spi::master::order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current SPI bus byte order. </p>
<dl class="section return"><dt>Returns</dt><dd>The currently configured byte order. </dd></dl>

<p class="reference">References <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a89626dd7c12eae0a5901f0151a6e4981">embvm::spi::master::order_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af62bd88b8683d12187d1c8ca815f4655">embvm::spi::master::order()</a>, and <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a751c7751c2c00b8aecdf908b63021df1">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::setOrder_()</a>.</p>

</div>
</div>
<a id="af62bd88b8683d12187d1c8ca815f4655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62bd88b8683d12187d1c8ca815f4655">&#9670;&nbsp;</a></span>order() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a> embvm::spi::master::order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the SPI bus byte order. </p>
<p>Derived classes must implement the <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a751c7751c2c00b8aecdf908b63021df1" title="Set the SPI bus byte order.">setOrder_()</a> function, which is reponsible for configuring the target hardware.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>The desired byte ordering. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new byte ordering. </dd></dl>

<p class="reference">References <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a756305bf86484e2ddcf3398aa16ac6e6">embvm::spi::master::order()</a>, <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a89626dd7c12eae0a5901f0151a6e4981">embvm::spi::master::order_</a>, and <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a251a8eae5933a341abce8e39927fcf7d">embvm::spi::master::setOrder_()</a>.</p>

</div>
</div>
<a id="a60b9c108c1157086cbb627960176678f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b9c108c1157086cbb627960176678f">&#9670;&nbsp;</a></span>process_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::process_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">ao_storage</a>&#160;</td>
          <td class="paramname"><em>pair</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::m_</a>, <a class="el" href="../../d4/d03/libm-bench_8cpp.html#abc7cd2b0d3943fe380f2d539ea295c87">r</a>, and <a class="el" href="../../d9/d2d/namespaceembvm_1_1this__thread.html#ae31943fd178f8f0b0072ea4a40e15bdb">embvm::this_thread::sleep_for()</a>.</p>

</div>
</div>
<a id="a74663ed700c8c5b1bd31a90cee46f80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74663ed700c8c5b1bd31a90cee46f80a">&#9670;&nbsp;</a></span>queuedCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> <a class="el" href="../../d0/da7/classembutil_1_1active_object.html">embutil::activeObject</a>&lt; <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt; , <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">embvm::spi::ao_storage</a> , TQueueSize, TLock, TCond &gt;::queuedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of operations in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of queued operations. </dd></dl>

</div>
</div>
<a id="af5ef4047fa20ec89cdaf4663f61bedd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ef4047fa20ec89cdaf4663f61bedd9">&#9670;&nbsp;</a></span>restart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embvm::DriverBase::restart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restart the driver. </p>
<p>Calls <a class="el" href="../../d1/dc2/group___framework_driver.html#adaebcecbe8194c8e644cfa1a579c808c" title="Stop the driver.">stop()</a> and then <a class="el" href="../../d1/dc2/group___framework_driver.html#aaa287e02a3ec4fbd9e97508c4c9fb8f9" title="Start the driver.">start()</a> on the driver. If the driver is not started, then it will be started after the <a class="el" href="../../d1/dc2/group___framework_driver.html#aaa287e02a3ec4fbd9e97508c4c9fb8f9" title="Start the driver.">start()</a> function is invoked. </p>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#aaa287e02a3ec4fbd9e97508c4c9fb8f9">embvm::DriverBase::start()</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#adaebcecbe8194c8e644cfa1a579c808c">embvm::DriverBase::stop()</a>.</p>

</div>
</div>
<a id="a8654a10388a3566b09a37088d434394c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8654a10388a3566b09a37088d434394c">&#9670;&nbsp;</a></span>setMode_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::setMode_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">embvm::spi::mode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the SPI bus mode. </p>
<p>This function is implemented by the derived class. It is responsible for configuring the target hardware to use the new mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The desired byte ordering. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a3441d494e27c53c453288009048a2bcd">embvm::spi::master</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::m_</a>, and <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af850a9b2a8aae19bc06845257ff200ca">embvm::spi::master::mode()</a>.</p>

</div>
</div>
<a id="a751c7751c2c00b8aecdf908b63021df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751c7751c2c00b8aecdf908b63021df1">&#9670;&nbsp;</a></span>setOrder_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::setOrder_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">embvm::spi::order</a>&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the SPI bus byte order. </p>
<p>This function is implemented by the derived class. It is responsible for configuring the target hardware to use the new byte ordering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>The desired byte ordering. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a251a8eae5933a341abce8e39927fcf7d">embvm::spi::master</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::m_</a>, and <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a756305bf86484e2ddcf3398aa16ac6e6">embvm::spi::master::order()</a>.</p>

</div>
</div>
<a id="a1ebe65c68a084a00920582bd2140a458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebe65c68a084a00920582bd2140a458">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d0/da7/classembutil_1_1active_object.html">embutil::activeObject</a>&lt; <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt; , <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a0db51b326d7a22f23fc1756e0b209f03">embvm::spi::ao_storage</a> , TQueueSize, TLock, TCond &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdown the active object. </p>
<p>Call this function in the parent class destructor to stop the AO thread operation before destroying the parent class. This will prevent memory access problems due to race conidtions during destruction.</p>
<p>This function is marked noexcept because we want the program to terminate if an exception results from this call.</p>
<p>The shutdown process is permanent and cannot be reversed without recreating the object. </p>

</div>
</div>
<a id="aaa287e02a3ec4fbd9e97508c4c9fb8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa287e02a3ec4fbd9e97508c4c9fb8f9">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embvm::DriverBase::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the driver. </p>
<p>If the driver is not started, call the <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a44b91f29cebaf6d3778462978c46e70c" title="Derived classes override the start_ method to control driver-specific startup behavior.">start_()</a> function defined by the derived class. (Template Method Pattern) </p>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#af11adc89aa0aee240c752affa6e8c49a">embvm::DriverBase::start_()</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#a403d296e5ae7c65ea7d6faf57c0386a8">embvm::DriverBase::started_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d0/d85/class_n_r_f52_dongle_h_w_platform.html#afd19e214b2c27c14af92424231b5f67f">NRF52DongleHWPlatform::init_()</a>, <a class="el" href="../../de/d3c/class_n_r_f52_d_k_h_w_platform.html#aa4e949af0b3ea1854f5ff6f3e3f7dd31">NRF52DKHWPlatform::init_()</a>, <a class="el" href="../../d5/d37/class_blinky_simulator_h_w_platform.html#adfea87ef9107ac7af78fd727ac6da03e">BlinkySimulatorHWPlatform::init_()</a>, <a class="el" href="../../de/de5/class_f_w_demo_simulator_h_w_platform.html#a1750ab0d50f63d9464d4ee4b92ed44e4">FWDemoSimulatorHWPlatform::init_()</a>, <a class="el" href="../../d9/dfd/class_framework_demo_sim_platform.html#a8b9203b7a676567a4ff20b02d1b0f729">FrameworkDemoSimPlatform::initHWPlatform_()</a>, <a class="el" href="../../d1/dc2/group___framework_driver.html#af5ef4047fa20ec89cdaf4663f61bedd9">embvm::DriverBase::restart()</a>, <a class="el" href="../../d4/d88/classembvm_1_1timer_1_1_timer.html#a9f6011279ceecdbdba518bdc2328d67a">embvm::timer::Timer::restart()</a>, <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a44b91f29cebaf6d3778462978c46e70c">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::start_()</a>, <a class="el" href="../../dc/dd6/classembvm_1_1i2c_1_1active_master.html#a47cf965cf695620d27dce28c0cd7bff2">embvm::i2c::activeMaster&lt; 128 &gt;::start_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a448fb7db042a03f3d91c850901ee21bf">embdrv::aardvarkSPIMaster::start_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#adb82efc85a59f38eb0147228bf3faa22">embdrv::aardvarkI2CMaster::start_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#adab9959d27b1e003ed777dcb166b1ec8">embdrv::aardvarkGPIOInput&lt; 4 &gt;::start_()</a>, <a class="el" href="../../de/d39/group___framework_drivers.html#a428d48d26d1e1c4fd8897b14745b13c6">embdrv::vl53l1x::start_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a11cd0f00c9dda3cc15a09f47fe3c3c30">embdrv::aardvarkGPIOOutput&lt; 5 &gt;::start_()</a>, <a class="el" href="../../d5/d37/class_blinky_simulator_h_w_platform.html#a267a8d631c8ed68523c180c47fc7c3d5">BlinkySimulatorHWPlatform::startBlink()</a>, and <a class="el" href="../../de/de5/class_f_w_demo_simulator_h_w_platform.html#a9516946a19941f7fc2173481644fd8b2">FWDemoSimulatorHWPlatform::startLEDTimer()</a>.</p>

</div>
</div>
<a id="a44b91f29cebaf6d3778462978c46e70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b91f29cebaf6d3778462978c46e70c">&#9670;&nbsp;</a></span>start_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::start_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes override the start_ method to control driver-specific startup behavior. </p>
<p>(Template Method Pattern) </p>

<p>Implements <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a93419a70710f747924d38dc4341e5420">embvm::spi::master</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::m_</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#aaa287e02a3ec4fbd9e97508c4c9fb8f9">embvm::DriverBase::start()</a>.</p>

</div>
</div>
<a id="a01670f19d5b777d92139ff80523c1f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01670f19d5b777d92139ff80523c1f4c">&#9670;&nbsp;</a></span>started()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type_safe::boolean embvm::DriverBase::started </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the driver has been started. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the driver is running (started), <code>false</code> if not running (stopped). </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#a403d296e5ae7c65ea7d6faf57c0386a8">embvm::DriverBase::started_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a83ec6571607172b447d638667a69104d">embdrv::aardvarkSPIMaster::configure_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a1972d4c07c314eb650a2b079ec42c378">embdrv::aardvarkGPIOInput&lt; 4 &gt;::get()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a83cc218bd33d1f758392debe2cfc2712">embdrv::aardvarkGPIOOutput&lt; 5 &gt;::set()</a>, <a class="el" href="../../de/d39/group___framework_drivers.html#a428d48d26d1e1c4fd8897b14745b13c6">embdrv::vl53l1x::start_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a6c62e11fdabf4ca9d3f3fe28b12888aa">embdrv::aardvarkAdapter::start_()</a>, and <a class="el" href="../../d6/d18/group___aardvark_drivers.html#aa34e430f2be7edf8991b31dc1c1bdd01">embdrv::aardvarkAdapter::stop_()</a>.</p>

</div>
</div>
<a id="adaebcecbe8194c8e644cfa1a579c808c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaebcecbe8194c8e644cfa1a579c808c">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void embvm::DriverBase::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the driver. </p>
<p>If the driver has been started, call the <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a3c2a66c260ceb8d262ea1ee2ea42d718" title="Derived classes override the start_ method to control driver-specific startup behavior.">stop_()</a> function defined by the derived class. (Template Method Pattern) </p>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#a403d296e5ae7c65ea7d6faf57c0386a8">embvm::DriverBase::started_</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#a6b5f7c46031fd1bffa6e4f366b79edbc">embvm::DriverBase::stop_()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc2/group___framework_driver.html#af5ef4047fa20ec89cdaf4663f61bedd9">embvm::DriverBase::restart()</a>, <a class="el" href="../../d4/d88/classembvm_1_1timer_1_1_timer.html#a9f6011279ceecdbdba518bdc2328d67a">embvm::timer::Timer::restart()</a>, <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a3c2a66c260ceb8d262ea1ee2ea42d718">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::stop_()</a>, <a class="el" href="../../dc/dd6/classembvm_1_1i2c_1_1active_master.html#a113f21df4d6f1f88575eea079de1e0f4">embvm::i2c::activeMaster&lt; 128 &gt;::stop_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a89f5dca70672ff2d3b221212ba94ff26">embdrv::aardvarkSPIMaster::stop_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#ab713e2000cdb48bf913f8cb057a6a8eb">embdrv::aardvarkI2CMaster::stop_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a037ce0b5b703714ee7c2cf973833e019">embdrv::aardvarkGPIOInput&lt; 4 &gt;::stop_()</a>, <a class="el" href="../../d6/d18/group___aardvark_drivers.html#aecda78e431cac64e54fd5f9e1e6af015">embdrv::aardvarkGPIOOutput&lt; 5 &gt;::stop_()</a>, <a class="el" href="../../de/de5/class_f_w_demo_simulator_h_w_platform.html#a15b7deb18822bcc5fdac38736567a771">FWDemoSimulatorHWPlatform::~FWDemoSimulatorHWPlatform()</a>, and <a class="el" href="../../db/d9d/group___simulator_drivers.html#a0670cb396d8d9af823a1abf213d4a5eb">embdrv::SimulatorTimer::~SimulatorTimer()</a>.</p>

</div>
</div>
<a id="a3c2a66c260ceb8d262ea1ee2ea42d718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2a66c260ceb8d262ea1ee2ea42d718">&#9670;&nbsp;</a></span>stop_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::stop_ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Derived classes override the start_ method to control driver-specific startup behavior. </p>
<p>(Template Method Pattern) </p>

<p>Implements <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a665746b2e65fdf3fc3c1eab4e1e07206">embvm::spi::master</a>.</p>

<p class="reference">References <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a0a3d7e06bbec9b558c405d7d40c7a042">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::m_</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#adaebcecbe8194c8e644cfa1a579c808c">embvm::DriverBase::stop()</a>.</p>

</div>
</div>
<a id="a69fbff3a41f758a69f08f77b2d56608a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fbff3a41f758a69f08f77b2d56608a">&#9670;&nbsp;</a></span>transfer_() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d19/namespaceembvm_1_1comm.html#ab1bb117426da7307c65bf9b7e782a901">embvm::spi::status</a> <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::transfer_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#d5/d30/structembvm_1_1spi_1_1op__t">embvm::spi::op_t</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const embvm::spi::master::cb_t &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="../../d0/da7/classembutil_1_1active_object.html#a8c5d2316c316a6dc6d78f28a96eef47f">embutil::activeObject&lt; TDerivedClass, TStorageType, TQueueSize, TLock, TCond &gt;::enqueue()</a>.</p>

</div>
</div>
<a id="af43bc466c185cf3d79f3b715ce00559b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af43bc466c185cf3d79f3b715ce00559b">&#9670;&nbsp;</a></span>transfer_() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d19/namespaceembvm_1_1comm.html#ab1bb117426da7307c65bf9b7e782a901">embvm::comm::status</a> embvm::spi::master::transfer_ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#d5/d30/structembvm_1_1spi_1_1op__t">spi::op_t</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cb_t &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a0e4c36efdcc841ef5491ccf5f18b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0e4c36efdcc841ef5491ccf5f18b26">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="../../d1/dc2/group___framework_driver.html#ga92dffcfd32d2dee7a13ab04beb3f4b33">embvm::DriverType</a> embvm::spi::master::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SPI Driver Type ID. </p>
<dl class="section return"><dt>Returns</dt><dd>SPI type ID. </dd></dl>

<p class="reference">References <a class="el" href="../../d1/dc2/group___framework_driver.html#gga92dffcfd32d2dee7a13ab04beb3f4b33ac47859609efe03122305d190061a3c7a">embvm::SPI</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0a3d7e06bbec9b558c405d7d40c7a042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d7e06bbec9b558c405d7d40c7a042">&#9670;&nbsp;</a></span>m_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t TQueueSize = 0, typename TLock  = std::mutex, typename TCond  = std::condition_variable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html">embvm::spi::master</a>&amp; <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html">embvm::spi::activeMaster</a>&lt; TQueueSize, TLock, TCond &gt;::m_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#aab3596c2f3e30606b07b2dd474cc0a21">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::baudrate_()</a>, <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a60b9c108c1157086cbb627960176678f">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::process_()</a>, <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a8654a10388a3566b09a37088d434394c">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::setMode_()</a>, <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a751c7751c2c00b8aecdf908b63021df1">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::setOrder_()</a>, <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a44b91f29cebaf6d3778462978c46e70c">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::start_()</a>, and <a class="el" href="../../d2/d2e/classembvm_1_1spi_1_1active_master.html#a3c2a66c260ceb8d262ea1ee2ea42d718">embvm::spi::activeMaster&lt; TQueueSize, TLock, TCond &gt;::stop_()</a>.</p>

</div>
</div>
<a id="a07d12d6819071802957b949ff5b9a4ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d12d6819071802957b949ff5b9a4ad">&#9670;&nbsp;</a></span>mode_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05">spi::mode</a> embvm::spi::master::mode_ = <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#a3a91ad82f8f99b547adcacb25d0aeb05ab4f91f3e8dc5079cab466793ebf3d0cf">spi::mode::mode0</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the active SPI mode configuration. </p>

<p class="reference">Referenced by <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a83ec6571607172b447d638667a69104d">embdrv::aardvarkSPIMaster::configure_()</a>, and <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#af850a9b2a8aae19bc06845257ff200ca">embvm::spi::master::mode()</a>.</p>

</div>
</div>
<a id="abea20098162d8ad9d7732ef409ef3e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea20098162d8ad9d7732ef409ef3e68">&#9670;&nbsp;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view embvm::DriverBase::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Name of the driver instance. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc2/group___framework_driver.html#ae860062cec176fd6d0f27c3444005524">embvm::DriverBase::name()</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#ad0238f8ee997b79a1678bea9cb6154fd">embvm::DriverBase::name_cstr()</a>.</p>

</div>
</div>
<a id="a89626dd7c12eae0a5901f0151a6e4981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89626dd7c12eae0a5901f0151a6e4981">&#9670;&nbsp;</a></span>order_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdea">spi::order</a> embvm::spi::master::order_ = <a class="el" href="../../d4/d68/namespaceembvm_1_1spi.html#aed8589e9b1a7ff24814a211e29dffdeaa82a53f458a5666053e97da7b866d8922">spi::order::msbFirst</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the active SPI byte ordering. </p>

<p class="reference">Referenced by <a class="el" href="../../d6/d18/group___aardvark_drivers.html#a83ec6571607172b447d638667a69104d">embdrv::aardvarkSPIMaster::configure_()</a>, and <a class="el" href="../../d4/da2/classembvm_1_1spi_1_1master.html#a756305bf86484e2ddcf3398aa16ac6e6">embvm::spi::master::order()</a>.</p>

</div>
</div>
<a id="a403d296e5ae7c65ea7d6faf57c0386a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403d296e5ae7c65ea7d6faf57c0386a8">&#9670;&nbsp;</a></span>started_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">type_safe::boolean embvm::DriverBase::started_ = <a class="el" href="../../dc/d6c/test__suite_8cpp.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tracks the driver state. </p>
<p>True if the driver has been started, false if it has been stopped or not yet started. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc2/group___framework_driver.html#aaa287e02a3ec4fbd9e97508c4c9fb8f9">embvm::DriverBase::start()</a>, <a class="el" href="../../d1/dc2/group___framework_driver.html#a01670f19d5b777d92139ff80523c1f4c">embvm::DriverBase::started()</a>, and <a class="el" href="../../d1/dc2/group___framework_driver.html#adaebcecbe8194c8e644cfa1a579c808c">embvm::DriverBase::stop()</a>.</p>

</div>
</div>
<a id="abbce4c3b40f00a6a88db890b24e362b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbce4c3b40f00a6a88db890b24e362b2">&#9670;&nbsp;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d1/dc2/group___framework_driver.html#gab080d1ffd9eaaddfe5cc7f59df79b915">embvm::DriverType_t</a> embvm::DriverBase::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type ID of the driver instance. </p>

<p class="reference">Referenced by <a class="el" href="../../d1/dc2/group___framework_driver.html#a589a09f7583ca866df9f7357d162f2be">embvm::DriverBase::DriverType()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/core/driver/<a class="el" href="../../d0/da6/active__spi_8hpp.html">active_spi.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
