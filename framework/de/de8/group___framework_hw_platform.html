<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry Framework: Framework Hardware Platform Infrastructure</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Artistry Framework
   </div>
   <div id="projectbrief">Embedded Systems C++ Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Framework Hardware Platform Infrastructure<div class="ingroups"><a class="el" href="../../de/d4e/group___framework_core.html">Framework Core Components</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Interfaces and components for building a virtual hardware platform.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Framework Hardware Platform Infrastructure:</div>
<div class="dyncontent">
<center><table><tr><td><img src="../../de/de8/group___framework_hw_platform.jpg" border="0" alt="" usemap="#de_2de8_2group______framework__hw__platform"/>
<map name="de_2de8_2group______framework__hw__platform" id="de_2de8_2group______framework__hw__platform">
<area shape="rect"  href="../../de/d4e/group___framework_core.html" title="Classes, interfaces, and definitions related to the framework core components." alt="" coords="5,12,205,36"/>
<area shape="rect"  title="Interfaces and components for building a virtual hardware platform." alt="" coords="253,5,410,43"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:de/ddc/classembvm_1_1_timer_manager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;</a></td></tr>
<tr class="memdesc:de/ddc/classembvm_1_1_timer_manager"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timer Manager Class.  <a href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">More...</a><br /></td></tr>
<tr class="separator:de/ddc/classembvm_1_1_timer_manager"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d0/d7f/classembvm_1_1_virtual_hw_platform_base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase&lt; THWPlatform &gt;</a></td></tr>
<tr class="memdesc:d0/d7f/classembvm_1_1_virtual_hw_platform_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual Hardware Platform Base.  <a href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">More...</a><br /></td></tr>
<tr class="separator:d0/d7f/classembvm_1_1_virtual_hw_platform_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Interfaces and components for building a virtual hardware platform. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="de/ddc/classembvm_1_1_timer_manager" id="de/ddc/classembvm_1_1_timer_manager"></a>
<h2 class="memtitle"><span class="permalink"><a href="#de/ddc/classembvm_1_1_timer_manager">&#9670;&nbsp;</a></span>embvm::TimerManager</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class embvm::TimerManager</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt;<br />
class embvm::TimerManager&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;</h3>

<p>Timer Manager Class. </p>
<p>The Timer Manager takes a hardware timer and uses it to produce a number of software timers.</p>
<p>An alternative structure accomplishing this task is the <code>callback_timer</code> provided by ETL in <code>callback_timer.h</code>, which uses a <code>tick()</code> function: <a href="https://www.etlcpp.com/callback_timer.html">https://www.etlcpp.com/callback_timer.html</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TMaxTimers</td><td>The maximum number of software timers that can be created. Size 0 indicates dynamic memory will be used. All other sizes will enable static memory allocation. </td></tr>
    <tr><td class="paramname">TLock</td><td>The type of lock interface to use. Default is <a class="el" href="../../d7/db0/classembutil_1_1nop__lock.html" title="Use this lock class to disable locking behavior at compile-time.">embutil::nop_lock</a>, which disables locking. To enable locking, declare <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> with a functional lock type. <div class="fragment"><div class="line"><span class="keyword">using</span> TimerManager_t = <a class="code" href="../../de/de8/group___framework_hw_platform.html">embvm::TimerManager&lt;0, std::mutex&gt;</a>;</div></div><!-- fragment --> </td></tr>
    <tr><td class="paramname">TTimeUnit</td><td>The time-keeping units. The default <code><a class="el" href="../../d9/d18/namespaceembvm_1_1timer.html#ab2a98142d1532f052543032eb7306d97" title="Represents the period of the timer, in microseconds.">embvm::timer::timer_period_t</a></code> is inherited from the Timer base class. This can be overriden to provide a specific timer resolution (e.g. 1ms instead of 1us). TTimeUnit is limited by the granularity that the Timer can support. </td></tr>
    <tr><td class="paramname">TTimeoutCallback</td><td>The storage type for the callback function. </td></tr>
    <tr><td class="paramname">TTimerDevice</td><td>The type of timer device that this class will manage. The default Timer type is the base class that framework timers derive from. </td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for embvm::TimerManager&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../d3/d0d/classembvm_1_1_timer_manager__inherit__graph.jpg" border="0" usemap="#embvm_1_1_timer_manager_3_01_t_max_timers_00_01_t_lock_00_01_t_time_unit_00_01_t_timeout_callback_00_01_t_timer_device_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="embvm_1_1_timer_manager_3_01_t_max_timers_00_01_t_lock_00_01_t_time_unit_00_01_t_timeout_callback_00_01_t_timer_device_01_4_inherit__map" id="embvm_1_1_timer_manager_3_01_t_max_timers_00_01_t_lock_00_01_t_time_unit_00_01_t_timeout_callback_00_01_t_timer_device_01_4_inherit__map">
<area shape="rect"  title="Timer Manager Class." alt="" coords="5,5,211,479"/>
<area shape="rect"  href="../../de/de8/group___framework_hw_platform.html" title=" " alt="" coords="5,540,211,987"/>
</map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Types</h3></td></tr>
<tr class="memitem:a3f7fbe7e567d0233333116aced1eb178"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a3f7fbe7e567d0233333116aced1eb178">DispatcherFunc</a> = stdext::inplace_function&lt; void(const TTimeoutCallback &amp;)&gt;</td></tr>
<tr class="memdesc:a3f7fbe7e567d0233333116aced1eb178"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function prototype for the Dispatcher.  <a href="#a3f7fbe7e567d0233333116aced1eb178">More...</a><br /></td></tr>
<tr class="separator:a3f7fbe7e567d0233333116aced1eb178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a69a8a3fc190d248cd9b3818553862e6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a69a8a3fc190d248cd9b3818553862e6f">TimerManager</a> (TTimerDevice &amp;timer) noexcept</td></tr>
<tr class="memdesc:a69a8a3fc190d248cd9b3818553862e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> without a dispatcher.  <a href="#a69a8a3fc190d248cd9b3818553862e6f">More...</a><br /></td></tr>
<tr class="separator:a69a8a3fc190d248cd9b3818553862e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2766356825d74cfb160218c4ef1638a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#aa2766356825d74cfb160218c4ef1638a">TimerManager</a> (TTimerDevice &amp;timer, const <a class="el" href="../../de/de8/group___framework_hw_platform.html#a3f7fbe7e567d0233333116aced1eb178">DispatcherFunc</a> &amp;dispatcher) noexcept</td></tr>
<tr class="memdesc:aa2766356825d74cfb160218c4ef1638a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> with a dispatcher.  <a href="#aa2766356825d74cfb160218c4ef1638a">More...</a><br /></td></tr>
<tr class="separator:aa2766356825d74cfb160218c4ef1638a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48155d213c681b03c9a4780515c8da6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ae48155d213c681b03c9a4780515c8da6">~TimerManager</a> () noexcept</td></tr>
<tr class="memdesc:ae48155d213c681b03c9a4780515c8da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a>.  <a href="#ae48155d213c681b03c9a4780515c8da6">More...</a><br /></td></tr>
<tr class="separator:ae48155d213c681b03c9a4780515c8da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427587137beafffd6abc1a2a9f5d8060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a427587137beafffd6abc1a2a9f5d8060">TimerManager</a> (const <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> &amp;)=delete</td></tr>
<tr class="memdesc:a427587137beafffd6abc1a2a9f5d8060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a427587137beafffd6abc1a2a9f5d8060">More...</a><br /></td></tr>
<tr class="separator:a427587137beafffd6abc1a2a9f5d8060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53f35437980af20864460add8a856b2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ad53f35437980af20864460add8a856b2">operator=</a> (const <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> &amp;)=delete</td></tr>
<tr class="memdesc:ad53f35437980af20864460add8a856b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#ad53f35437980af20864460add8a856b2">More...</a><br /></td></tr>
<tr class="separator:ad53f35437980af20864460add8a856b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09d272381a802f055aa6e047b026053"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ae09d272381a802f055aa6e047b026053">TimerManager</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:ae09d272381a802f055aa6e047b026053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor.  <a href="#ae09d272381a802f055aa6e047b026053">More...</a><br /></td></tr>
<tr class="separator:ae09d272381a802f055aa6e047b026053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af811b8abcc2c5ab335fae77e955564ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#af811b8abcc2c5ab335fae77e955564ea">operator=</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:af811b8abcc2c5ab335fae77e955564ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator.  <a href="#af811b8abcc2c5ab335fae77e955564ea">More...</a><br /></td></tr>
<tr class="separator:af811b8abcc2c5ab335fae77e955564ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999b252676f73e445e9a2cdb8e82cb48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/dd0/classembvm_1_1_timer_manager_1_1_timer_handle.html">TimerHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a999b252676f73e445e9a2cdb8e82cb48">allocate</a> () noexcept</td></tr>
<tr class="memdesc:a999b252676f73e445e9a2cdb8e82cb48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new software timer.  <a href="#a999b252676f73e445e9a2cdb8e82cb48">More...</a><br /></td></tr>
<tr class="separator:a999b252676f73e445e9a2cdb8e82cb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Types</h3></td></tr>
<tr class="memitem:a543b6429396dc4710518818d6c918bce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a543b6429396dc4710518818d6c918bce">TimeRep_t</a> = typename TTimeUnit::rep</td></tr>
<tr class="memdesc:a543b6429396dc4710518818d6c918bce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for the time unit representation (e.g., uint32_t, uint64_t)  <a href="#a543b6429396dc4710518818d6c918bce">More...</a><br /></td></tr>
<tr class="separator:a543b6429396dc4710518818d6c918bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a049345bc7693e7dec8222215c0d9e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ac9a049345bc7693e7dec8222215c0d9e">TTimerQueueType</a> = typename std::conditional&lt;(TMaxTimers==0), std::list&lt; <a class="el" href="../../df/d96/structembvm_1_1_timer_manager_1_1delay_info.html">delayInfo</a> &gt;, etl::list&lt; <a class="el" href="../../df/d96/structembvm_1_1_timer_manager_1_1delay_info.html">delayInfo</a>, TMaxTimers &gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td></tr>
<tr class="memdesc:ac9a049345bc7693e7dec8222215c0d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for the underlying timer queue.  <a href="#ac9a049345bc7693e7dec8222215c0d9e">More...</a><br /></td></tr>
<tr class="separator:ac9a049345bc7693e7dec8222215c0d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6f9170a17aff131bcb15b0fc36b94e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> = typename TTimerQueueType::iterator</td></tr>
<tr class="memdesc:afd6f9170a17aff131bcb15b0fc36b94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for the queue handle type.  <a href="#afd6f9170a17aff131bcb15b0fc36b94e">More...</a><br /></td></tr>
<tr class="separator:afd6f9170a17aff131bcb15b0fc36b94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e3ab79c0d36a1713276ae21ba03b97"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a95e3ab79c0d36a1713276ae21ba03b97">TScheduledQueueType</a> = typename std::conditional&lt;(TMaxTimers==0), std::vector&lt; <a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> &gt;, etl::vector&lt; <a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>, TMaxTimers &gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td></tr>
<tr class="memdesc:a95e3ab79c0d36a1713276ae21ba03b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the queue of scheduled timers.  <a href="#a95e3ab79c0d36a1713276ae21ba03b97">More...</a><br /></td></tr>
<tr class="separator:a95e3ab79c0d36a1713276ae21ba03b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Member Functions</h3></td></tr>
<tr class="memitem:af5e2b8c0df39c9b44d43e883af284a0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#af5e2b8c0df39c9b44d43e883af284a0f">TimerManagerDispatch</a> (const TTimeoutCallback &amp;op) noexcept</td></tr>
<tr class="memdesc:af5e2b8c0df39c9b44d43e883af284a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> Default Dispatch Function.  <a href="#af5e2b8c0df39c9b44d43e883af284a0f">More...</a><br /></td></tr>
<tr class="separator:af5e2b8c0df39c9b44d43e883af284a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4282312a8ff6eefb097c2159015bd1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a4282312a8ff6eefb097c2159015bd1b7">TimerInterruptHandler</a> () noexcept</td></tr>
<tr class="memdesc:a4282312a8ff6eefb097c2159015bd1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a>'s Timer Interrupt Handler.  <a href="#a4282312a8ff6eefb097c2159015bd1b7">More...</a><br /></td></tr>
<tr class="separator:a4282312a8ff6eefb097c2159015bd1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d5077d1ef8e2616be0161de5c7f209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a35d5077d1ef8e2616be0161de5c7f209">addToScheduledQueue</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> handle) noexcept</td></tr>
<tr class="separator:a35d5077d1ef8e2616be0161de5c7f209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45793db56ab46530281d3a2949fea38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ab45793db56ab46530281d3a2949fea38">popScheduledQueueFront</a> () noexcept</td></tr>
<tr class="separator:ab45793db56ab46530281d3a2949fea38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad013e65bae7885d5cfc5bd8b3f3677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#acad013e65bae7885d5cfc5bd8b3f3677">lockAndPopScheduledQueueFront</a> () noexcept</td></tr>
<tr class="separator:acad013e65bae7885d5cfc5bd8b3f3677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cae75de4175faa6a8db025517a55f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a0cae75de4175faa6a8db025517a55f03">adjustScheduledTimerCount</a> (TTimeUnit time_base) noexcept</td></tr>
<tr class="separator:a0cae75de4175faa6a8db025517a55f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87dbe93609432b66263471f1971ca29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ab87dbe93609432b66263471f1971ca29">startNextTimer</a> () noexcept</td></tr>
<tr class="separator:ab87dbe93609432b66263471f1971ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9ed4039811b90f2ace5bf50aba3818"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a5c9ed4039811b90f2ace5bf50aba3818">stopRunningTimer</a> () noexcept</td></tr>
<tr class="separator:a5c9ed4039811b90f2ace5bf50aba3818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4085c2a8ad8e987ea840289dbe0b2b8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a4085c2a8ad8e987ea840289dbe0b2b8e">schedule</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> handle, TTimeUnit delay, const TTimeoutCallback &amp;func, <a class="el" href="../../d9/d18/namespaceembvm_1_1timer.html#a3191fbd1ad35f37c8921d99e9138b235">embvm::timer::config</a> config) noexcept</td></tr>
<tr class="separator:a4085c2a8ad8e987ea840289dbe0b2b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae602f25ade8ca14acf722e9072423a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ae602f25ade8ca14acf722e9072423a97">schedule</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> handle, TTimeUnit delay, TTimeoutCallback &amp;&amp;func, <a class="el" href="../../d9/d18/namespaceembvm_1_1timer.html#a3191fbd1ad35f37c8921d99e9138b235">embvm::timer::config</a> config) noexcept</td></tr>
<tr class="separator:ae602f25ade8ca14acf722e9072423a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af854c3ca0848f817f9ca6758ec5ca3d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">cancel</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> handle) noexcept</td></tr>
<tr class="memdesc:af854c3ca0848f817f9ca6758ec5ca3d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns false if no wait was scheduled or if the callback was already called Returns true if cancelled successfully.  <a href="#af854c3ca0848f817f9ca6758ec5ca3d7">More...</a><br /></td></tr>
<tr class="separator:af854c3ca0848f817f9ca6758ec5ca3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded0a435254ef4e98f1d8f1b527f5d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#aded0a435254ef4e98f1d8f1b527f5d19">deleteTimer</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> handle) noexcept</td></tr>
<tr class="separator:aded0a435254ef4e98f1d8f1b527f5d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26d0b57d747aa30336695536c183a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ae26d0b57d747aa30336695536c183a0b">sortScheduledQueue</a> () noexcept</td></tr>
<tr class="separator:ae26d0b57d747aa30336695536c183a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3844a5bfa08f5b6a948a6d13626cd74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ab3844a5bfa08f5b6a948a6d13626cd74">clearExpiredTimers</a> () noexcept</td></tr>
<tr class="separator:ab3844a5bfa08f5b6a948a6d13626cd74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a07806da405c8ff8797ed596c0d45e049"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#a3f7fbe7e567d0233333116aced1eb178">DispatcherFunc</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a07806da405c8ff8797ed596c0d45e049">dispatcher_</a></td></tr>
<tr class="separator:a07806da405c8ff8797ed596c0d45e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33293444ce2ab857948f954f94f06d97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ac9a049345bc7693e7dec8222215c0d9e">TTimerQueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a33293444ce2ab857948f954f94f06d97">timer_list_</a> {}</td></tr>
<tr class="separator:a33293444ce2ab857948f954f94f06d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ccec874bbad06add1d1f392c1aabc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a95e3ab79c0d36a1713276ae21ba03b97">TScheduledQueueType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a8a6ccec874bbad06add1d1f392c1aabc">scheduled_queue_</a> {}</td></tr>
<tr class="separator:a8a6ccec874bbad06add1d1f392c1aabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ea45de0e996f14f90f27d2327615c8"><td class="memItemLeft" align="right" valign="top">TLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a05ea45de0e996f14f90f27d2327615c8">scheduled_q_lock_</a></td></tr>
<tr class="separator:a05ea45de0e996f14f90f27d2327615c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bf46e81482d17c51a8c682c2031897"><td class="memItemLeft" align="right" valign="top">TLock&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ae1bf46e81482d17c51a8c682c2031897">timer_list_lock_</a></td></tr>
<tr class="separator:ae1bf46e81482d17c51a8c682c2031897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d0fdefe7b348cc9faf141fd504cb01"><td class="memItemLeft" align="right" valign="top">TTimerDevice &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a32d0fdefe7b348cc9faf141fd504cb01">timer_hw_</a></td></tr>
<tr class="separator:a32d0fdefe7b348cc9faf141fd504cb01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Friends</h3></td></tr>
<tr class="memitem:aacfd3583a882558831c5581b422678e3"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#aacfd3583a882558831c5581b422678e3">TimerManager::TimerHandle</a></td></tr>
<tr class="memdesc:aacfd3583a882558831c5581b422678e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The timer handle can call private <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> functions.  <a href="#aacfd3583a882558831c5581b422678e3">More...</a><br /></td></tr>
<tr class="separator:aacfd3583a882558831c5581b422678e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Member Typedef Documentation</h4>
<a id="a3f7fbe7e567d0233333116aced1eb178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7fbe7e567d0233333116aced1eb178">&#9670;&nbsp;</a></span>DispatcherFunc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#a3f7fbe7e567d0233333116aced1eb178">DispatcherFunc</a> =  stdext::inplace_function&lt;void(const TTimeoutCallback&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function prototype for the Dispatcher. </p>
<p>The dispacher uses inplace_function regardless of static or dynamic memory allocation. </p>

</div>
</div>
<a id="a543b6429396dc4710518818d6c918bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543b6429396dc4710518818d6c918bce">&#9670;&nbsp;</a></span>TimeRep_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#a543b6429396dc4710518818d6c918bce">TimeRep_t</a> =  typename TTimeUnit::rep</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alias for the time unit representation (e.g., uint32_t, uint64_t) </p>

</div>
</div>
<a id="afd6f9170a17aff131bcb15b0fc36b94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6f9170a17aff131bcb15b0fc36b94e">&#9670;&nbsp;</a></span>TQueueHandle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a> =  typename TTimerQueueType::iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience alias for the queue handle type. </p>
<p>A list iterator is used because iterators remain valid even with insertion/deletions </p>

</div>
</div>
<a id="a95e3ab79c0d36a1713276ae21ba03b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e3ab79c0d36a1713276ae21ba03b97">&#9670;&nbsp;</a></span>TScheduledQueueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#a95e3ab79c0d36a1713276ae21ba03b97">TScheduledQueueType</a> =  typename std::conditional&lt;(TMaxTimers == 0), std::vector&lt;<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>&gt;, etl::vector&lt;<a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>, TMaxTimers&gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience type for the queue of scheduled timers. </p>
<p>This queue is used to manage the list of currently scheduled timers.</p>
<p>The size of the scheduled queue will be &lt;= the size of the allocated queue.</p>
<p>The type changes depending on whether static or dynamic memory allocation is being used (dynamic memory is indicated by <code>TMaxTimers == 0</code>) </p>

</div>
</div>
<a id="ac9a049345bc7693e7dec8222215c0d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9a049345bc7693e7dec8222215c0d9e">&#9670;&nbsp;</a></span>TTimerQueueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#ac9a049345bc7693e7dec8222215c0d9e">TTimerQueueType</a> =  typename std::conditional&lt;(TMaxTimers == 0), std::list&lt;<a class="el" href="../../df/d96/structembvm_1_1_timer_manager_1_1delay_info.html">delayInfo</a>&gt;, etl::list&lt;<a class="el" href="../../df/d96/structembvm_1_1_timer_manager_1_1delay_info.html">delayInfo</a>, TMaxTimers&gt; &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type definition for the underlying timer queue. </p>
<p>This type is used to manage timers which have been allocated.</p>
<p>The type changes depending on whether static or dynamic memory allocation is being used (dynamic memory is indicated by <code>TMaxTimers == 0</code>) </p>

</div>
</div>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a69a8a3fc190d248cd9b3818553862e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a8a3fc190d248cd9b3818553862e6f">&#9670;&nbsp;</a></span>TimerManager() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> </td>
          <td>(</td>
          <td class="paramtype">TTimerDevice &amp;&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> without a dispatcher. </p>
<p>Creating a <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> without a dispatcher will result in the manager invoking the functions.</p>
<p>When no dispatcher is used, timer callbacks are called directly by the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer hardware instance which the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> will manage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2766356825d74cfb160218c4ef1638a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2766356825d74cfb160218c4ef1638a">&#9670;&nbsp;</a></span>TimerManager() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> </td>
          <td>(</td>
          <td class="paramtype">TTimerDevice &amp;&#160;</td>
          <td class="paramname"><em>timer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#a3f7fbe7e567d0233333116aced1eb178">DispatcherFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>dispatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> with a dispatcher. </p>
<p>Creates a <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> class with an external dispatcher. When a timer expires, the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> forwards the callback to the dispatcher, rather than executing the callbacks directly. Using a dispatcher improves timer latency, as the manager is focused only on managing timers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>The timer hardware instance which the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> will manage. </td></tr>
    <tr><td class="paramname">dispatcher</td><td>Specifies a function which will dispatch all timer callbacks. Use <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> with a dispatch queue, or other type of system event queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae48155d213c681b03c9a4780515c8da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48155d213c681b03c9a4780515c8da6">&#9670;&nbsp;</a></span>~TimerManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::~<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a>. </p>
<p>On destruction, the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> stops the underlying timer hardware and unregisters the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a>'s timer interrupt callback. </p>

</div>
</div>
<a id="a427587137beafffd6abc1a2a9f5d8060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427587137beafffd6abc1a2a9f5d8060">&#9670;&nbsp;</a></span>TimerManager() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="ae09d272381a802f055aa6e047b026053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09d272381a802f055aa6e047b026053">&#9670;&nbsp;</a></span>TimerManager() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="a35d5077d1ef8e2616be0161de5c7f209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d5077d1ef8e2616be0161de5c7f209">&#9670;&nbsp;</a></span>addToScheduledQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::addToScheduledQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4085c2a8ad8e987ea840289dbe0b2b8e">embvm::TimerManager&lt; 0, std::mutex &gt;::schedule()</a>.</p>

</div>
</div>
<a id="a0cae75de4175faa6a8db025517a55f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cae75de4175faa6a8db025517a55f03">&#9670;&nbsp;</a></span>adjustScheduledTimerCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::adjustScheduledTimerCount </td>
          <td>(</td>
          <td class="paramtype">TTimeUnit&#160;</td>
          <td class="paramname"><em>time_base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">embvm::TimerManager&lt; 0, std::mutex &gt;::cancel()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4085c2a8ad8e987ea840289dbe0b2b8e">embvm::TimerManager&lt; 0, std::mutex &gt;::schedule()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4282312a8ff6eefb097c2159015bd1b7">embvm::TimerManager&lt; 0, std::mutex &gt;::TimerInterruptHandler()</a>.</p>

</div>
</div>
<a id="a999b252676f73e445e9a2cdb8e82cb48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999b252676f73e445e9a2cdb8e82cb48">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/dd0/classembvm_1_1_timer_manager_1_1_timer_handle.html">TimerHandle</a> <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate a new software timer. </p>
<p>Allocates a new timer in the <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> and returns a handle to the user.</p>
<dl class="section return"><dt>Returns</dt><dd>A handle to the allocated software timer. The handle is used by the consumer to configure the timer. The <a class="el" href="../../d1/dd0/classembvm_1_1_timer_manager_1_1_timer_handle.html" title="Handle to a software timer.">TimerHandle</a>'s lifetime controls the timer's lifetime - once the <a class="el" href="../../d1/dd0/classembvm_1_1_timer_manager_1_1_timer_handle.html" title="Handle to a software timer.">TimerHandle</a> leaves scope, the timer will be automatically unregistered. </dd></dl>

<p class="reference">Referenced by <a class="el" href="../../d5/d37/class_blinky_simulator_h_w_platform.html#a9e6c8fd45bf811235053dbcff2d58cd3">BlinkySimulatorHWPlatform::allocateTimer()</a>, and <a class="el" href="../../de/de5/class_f_w_demo_simulator_h_w_platform.html#a75a7eccddffc31e20d050f4feec13efc">FWDemoSimulatorHWPlatform::allocateTimer()</a>.</p>

</div>
</div>
<a id="af854c3ca0848f817f9ca6758ec5ca3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af854c3ca0848f817f9ca6758ec5ca3d7">&#9670;&nbsp;</a></span>cancel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns false if no wait was scheduled or if the callback was already called Returns true if cancelled successfully. </p>

</div>
</div>
<a id="ab3844a5bfa08f5b6a948a6d13626cd74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3844a5bfa08f5b6a948a6d13626cd74">&#9670;&nbsp;</a></span>clearExpiredTimers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::clearExpiredTimers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4085c2a8ad8e987ea840289dbe0b2b8e">embvm::TimerManager&lt; 0, std::mutex &gt;::schedule()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4282312a8ff6eefb097c2159015bd1b7">embvm::TimerManager&lt; 0, std::mutex &gt;::TimerInterruptHandler()</a>.</p>

</div>
</div>
<a id="aded0a435254ef4e98f1d8f1b527f5d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded0a435254ef4e98f1d8f1b527f5d19">&#9670;&nbsp;</a></span>deleteTimer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::deleteTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acad013e65bae7885d5cfc5bd8b3f3677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad013e65bae7885d5cfc5bd8b3f3677">&#9670;&nbsp;</a></span>lockAndPopScheduledQueueFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::lockAndPopScheduledQueueFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">embvm::TimerManager&lt; 0, std::mutex &gt;::cancel()</a>.</p>

</div>
</div>
<a id="ad53f35437980af20864460add8a856b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53f35437980af20864460add8a856b2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a>&amp; <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a id="af811b8abcc2c5ab335fae77e955564ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af811b8abcc2c5ab335fae77e955564ea">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a>&amp; <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator. </p>

</div>
</div>
<a id="ab45793db56ab46530281d3a2949fea38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45793db56ab46530281d3a2949fea38">&#9670;&nbsp;</a></span>popScheduledQueueFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::popScheduledQueueFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab3844a5bfa08f5b6a948a6d13626cd74">embvm::TimerManager&lt; 0, std::mutex &gt;::clearExpiredTimers()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#acad013e65bae7885d5cfc5bd8b3f3677">embvm::TimerManager&lt; 0, std::mutex &gt;::lockAndPopScheduledQueueFront()</a>.</p>

</div>
</div>
<a id="a4085c2a8ad8e987ea840289dbe0b2b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4085c2a8ad8e987ea840289dbe0b2b8e">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TTimeUnit&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TTimeoutCallback &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d18/namespaceembvm_1_1timer.html#a3191fbd1ad35f37c8921d99e9138b235">embvm::timer::config</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae602f25ade8ca14acf722e9072423a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae602f25ade8ca14acf722e9072423a97">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::schedule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afd6f9170a17aff131bcb15b0fc36b94e">TQueueHandle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TTimeUnit&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TTimeoutCallback &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/d18/namespaceembvm_1_1timer.html#a3191fbd1ad35f37c8921d99e9138b235">embvm::timer::config</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae26d0b57d747aa30336695536c183a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26d0b57d747aa30336695536c183a0b">&#9670;&nbsp;</a></span>sortScheduledQueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::sortScheduledQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a35d5077d1ef8e2616be0161de5c7f209">embvm::TimerManager&lt; 0, std::mutex &gt;::addToScheduledQueue()</a>.</p>

</div>
</div>
<a id="ab87dbe93609432b66263471f1971ca29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87dbe93609432b66263471f1971ca29">&#9670;&nbsp;</a></span>startNextTimer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::startNextTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">embvm::TimerManager&lt; 0, std::mutex &gt;::cancel()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4085c2a8ad8e987ea840289dbe0b2b8e">embvm::TimerManager&lt; 0, std::mutex &gt;::schedule()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4282312a8ff6eefb097c2159015bd1b7">embvm::TimerManager&lt; 0, std::mutex &gt;::TimerInterruptHandler()</a>.</p>

</div>
</div>
<a id="a5c9ed4039811b90f2ace5bf50aba3818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9ed4039811b90f2ace5bf50aba3818">&#9670;&nbsp;</a></span>stopRunningTimer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::stopRunningTimer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">embvm::TimerManager&lt; 0, std::mutex &gt;::cancel()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4085c2a8ad8e987ea840289dbe0b2b8e">embvm::TimerManager&lt; 0, std::mutex &gt;::schedule()</a>.</p>

</div>
</div>
<a id="a4282312a8ff6eefb097c2159015bd1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4282312a8ff6eefb097c2159015bd1b7">&#9670;&nbsp;</a></span>TimerInterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::TimerInterruptHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a>'s Timer Interrupt Handler. </p>
<p><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> registers its own interrupt with the Timer hardware driver. When the timer interrupt fires, we account for the time that has elapsed, clear all scheduled timers, and restart the timer hardware with the next timeout request.</p>
<p>Note that this must work with an interrupt bottom-half handler because locking calls are used here. It cannot be called directly in an ISR context! </p>

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a69a8a3fc190d248cd9b3818553862e6f">embvm::TimerManager&lt; 0, std::mutex &gt;::TimerManager()</a>.</p>

</div>
</div>
<a id="af5e2b8c0df39c9b44d43e883af284a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e2b8c0df39c9b44d43e883af284a0f">&#9670;&nbsp;</a></span>TimerManagerDispatch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::TimerManagerDispatch </td>
          <td>(</td>
          <td class="paramtype">const TTimeoutCallback &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> Default Dispatch Function. </p>
<p>If no external dispatcher is provided, <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> has one which just executes the operation by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The callback function object to execute. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h4 class="groupheader">Friends And Related Function Documentation</h4>
<a id="aacfd3583a882558831c5581b422678e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfd3583a882558831c5581b422678e3">&#9670;&nbsp;</a></span>TimerManager::TimerHandle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="../../d1/dd0/classembvm_1_1_timer_manager_1_1_timer_handle.html">TimerManager::TimerHandle</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The timer handle can call private <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager" title="Timer Manager Class.">TimerManager</a> functions. </p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="a07806da405c8ff8797ed596c0d45e049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07806da405c8ff8797ed596c0d45e049">&#9670;&nbsp;</a></span>dispatcher_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#a3f7fbe7e567d0233333116aced1eb178">DispatcherFunc</a> <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::dispatcher_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab3844a5bfa08f5b6a948a6d13626cd74">embvm::TimerManager&lt; 0, std::mutex &gt;::clearExpiredTimers()</a>.</p>

</div>
</div>
<a id="a05ea45de0e996f14f90f27d2327615c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ea45de0e996f14f90f27d2327615c8">&#9670;&nbsp;</a></span>scheduled_q_lock_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLock <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::scheduled_q_lock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a35d5077d1ef8e2616be0161de5c7f209">embvm::TimerManager&lt; 0, std::mutex &gt;::addToScheduledQueue()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a0cae75de4175faa6a8db025517a55f03">embvm::TimerManager&lt; 0, std::mutex &gt;::adjustScheduledTimerCount()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">embvm::TimerManager&lt; 0, std::mutex &gt;::cancel()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab3844a5bfa08f5b6a948a6d13626cd74">embvm::TimerManager&lt; 0, std::mutex &gt;::clearExpiredTimers()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#acad013e65bae7885d5cfc5bd8b3f3677">embvm::TimerManager&lt; 0, std::mutex &gt;::lockAndPopScheduledQueueFront()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#ae26d0b57d747aa30336695536c183a0b">embvm::TimerManager&lt; 0, std::mutex &gt;::sortScheduledQueue()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab87dbe93609432b66263471f1971ca29">embvm::TimerManager&lt; 0, std::mutex &gt;::startNextTimer()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a5c9ed4039811b90f2ace5bf50aba3818">embvm::TimerManager&lt; 0, std::mutex &gt;::stopRunningTimer()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#ae48155d213c681b03c9a4780515c8da6">embvm::TimerManager&lt; 0, std::mutex &gt;::~TimerManager()</a>.</p>

</div>
</div>
<a id="a8a6ccec874bbad06add1d1f392c1aabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6ccec874bbad06add1d1f392c1aabc">&#9670;&nbsp;</a></span>scheduled_queue_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a95e3ab79c0d36a1713276ae21ba03b97">TScheduledQueueType</a> <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::scheduled_queue_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a35d5077d1ef8e2616be0161de5c7f209">embvm::TimerManager&lt; 0, std::mutex &gt;::addToScheduledQueue()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a0cae75de4175faa6a8db025517a55f03">embvm::TimerManager&lt; 0, std::mutex &gt;::adjustScheduledTimerCount()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#af854c3ca0848f817f9ca6758ec5ca3d7">embvm::TimerManager&lt; 0, std::mutex &gt;::cancel()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab3844a5bfa08f5b6a948a6d13626cd74">embvm::TimerManager&lt; 0, std::mutex &gt;::clearExpiredTimers()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab45793db56ab46530281d3a2949fea38">embvm::TimerManager&lt; 0, std::mutex &gt;::popScheduledQueueFront()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#ae26d0b57d747aa30336695536c183a0b">embvm::TimerManager&lt; 0, std::mutex &gt;::sortScheduledQueue()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab87dbe93609432b66263471f1971ca29">embvm::TimerManager&lt; 0, std::mutex &gt;::startNextTimer()</a>.</p>

</div>
</div>
<a id="a32d0fdefe7b348cc9faf141fd504cb01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d0fdefe7b348cc9faf141fd504cb01">&#9670;&nbsp;</a></span>timer_hw_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TTimerDevice&amp; <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::timer_hw_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#ab87dbe93609432b66263471f1971ca29">embvm::TimerManager&lt; 0, std::mutex &gt;::startNextTimer()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a5c9ed4039811b90f2ace5bf50aba3818">embvm::TimerManager&lt; 0, std::mutex &gt;::stopRunningTimer()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a4282312a8ff6eefb097c2159015bd1b7">embvm::TimerManager&lt; 0, std::mutex &gt;::TimerInterruptHandler()</a>, <a class="el" href="../../de/de8/group___framework_hw_platform.html#a69a8a3fc190d248cd9b3818553862e6f">embvm::TimerManager&lt; 0, std::mutex &gt;::TimerManager()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#ae48155d213c681b03c9a4780515c8da6">embvm::TimerManager&lt; 0, std::mutex &gt;::~TimerManager()</a>.</p>

</div>
</div>
<a id="a33293444ce2ab857948f954f94f06d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33293444ce2ab857948f954f94f06d97">&#9670;&nbsp;</a></span>timer_list_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ac9a049345bc7693e7dec8222215c0d9e">TTimerQueueType</a> <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::timer_list_ {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a999b252676f73e445e9a2cdb8e82cb48">embvm::TimerManager&lt; 0, std::mutex &gt;::allocate()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#aded0a435254ef4e98f1d8f1b527f5d19">embvm::TimerManager&lt; 0, std::mutex &gt;::deleteTimer()</a>.</p>

</div>
</div>
<a id="ae1bf46e81482d17c51a8c682c2031897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bf46e81482d17c51a8c682c2031897">&#9670;&nbsp;</a></span>timer_list_lock_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const size_t TMaxTimers = 0, typename TLock = embutil::nop_lock, typename TTimeUnit = embvm::timer::timer_period_t, typename TTimeoutCallback = stdext::inplace_function&lt;void()&gt;, typename TTimerDevice = embvm::timer::Timer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TLock <a class="el" href="../../de/de8/group___framework_hw_platform.html#de/ddc/classembvm_1_1_timer_manager">embvm::TimerManager</a>&lt; TMaxTimers, TLock, TTimeUnit, TTimeoutCallback, TTimerDevice &gt;::timer_list_lock_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a999b252676f73e445e9a2cdb8e82cb48">embvm::TimerManager&lt; 0, std::mutex &gt;::allocate()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#aded0a435254ef4e98f1d8f1b527f5d19">embvm::TimerManager&lt; 0, std::mutex &gt;::deleteTimer()</a>.</p>

</div>
</div>

</div>
</div>
<a name="d0/d7f/classembvm_1_1_virtual_hw_platform_base" id="d0/d7f/classembvm_1_1_virtual_hw_platform_base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#d0/d7f/classembvm_1_1_virtual_hw_platform_base">&#9670;&nbsp;</a></span>embvm::VirtualHwPlatformBase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class embvm::VirtualHwPlatformBase</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename THWPlatform&gt;<br />
class embvm::VirtualHwPlatformBase&lt; THWPlatform &gt;</h3>

<p>Virtual Hardware Platform Base. </p>
<p>This class provides the common interfaces and behaviors that virtual hardware platforms must implement. Some functionality is common to all platforms (name functions).</p>
<p>Functions whose names are appended with <code>_</code> are meant to be supplied by the derived hardware platform:</p><ul>
<li>earlyInitHook_()</li>
<li>init_()</li>
<li>initProcessor_()</li>
<li>soft_reset_()</li>
<li>hard_reset_()</li>
<li>shutdown_()</li>
</ul>
<p>Derived classes may supply additional functions as required. The functions above are the common required functions that all hardware platforms must supply.</p>
<p>This class uses the docs/development/patterns/crtp.md ["CRTP pattern"] rather than virtual inheritance. To derive from this class, do the following: </p><div class="fragment"><div class="line"><span class="keyword">class </span><a class="code" href="../../de/de5/class_f_w_demo_simulator_h_w_platform.html">FWDemoSimulatorHWPlatform</a> : <span class="keyword">public</span> <a class="code" href="../../de/de8/group___framework_hw_platform.html#a27a3e83c46a815179b0a3062e449d1eb">VirtualHwPlatformBase</a>&lt;FWDemoSimulatorHWPlatform&gt;</div><div class="line">{ ... };</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">THWPlatform</td><td>the derived HW platform implementation (CRTP pattern) </td></tr>
  </table>
  </dd>
</dl>
</div><div class="dynheader">
Inheritance diagram for embvm::VirtualHwPlatformBase&lt; THWPlatform &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="../../da/d77/classembvm_1_1_virtual_hw_platform_base__inherit__graph.jpg" border="0" usemap="#embvm_1_1_virtual_hw_platform_base_3_01_t_h_w_platform_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="embvm_1_1_virtual_hw_platform_base_3_01_t_h_w_platform_01_4_inherit__map" id="embvm_1_1_virtual_hw_platform_base_3_01_t_h_w_platform_01_4_inherit__map">
<area shape="rect"  title="Virtual Hardware Platform Base." alt="" coords="542,5,729,292"/>
<area shape="rect"  href="../../de/de8/group___framework_hw_platform.html" title=" " alt="" coords="5,353,213,640"/>
<area shape="rect"  href="../../de/de8/group___framework_hw_platform.html" title=" " alt="" coords="237,353,496,640"/>
<area shape="rect"  href="../../de/de8/group___framework_hw_platform.html" title=" " alt="" coords="520,353,751,640"/>
<area shape="rect"  href="../../de/de8/group___framework_hw_platform.html" title=" " alt="" coords="775,353,1014,640"/>
<area shape="rect"  href="../../de/de8/group___framework_hw_platform.html" title=" " alt="" coords="1037,353,1232,640"/>
<area shape="rect"  href="../../de/d3c/class_n_r_f52_d_k_h_w_platform.html" title=" " alt="" coords="18,689,200,1109"/>
<area shape="rect"  href="../../de/de5/class_f_w_demo_simulator_h_w_platform.html" title="Framework Demo Simulator Hardware Platform." alt="" coords="249,696,483,1103"/>
<area shape="rect"  href="../../d0/d85/class_n_r_f52_dongle_h_w_platform.html" title=" " alt="" coords="533,756,739,1043"/>
<area shape="rect"  href="../../d5/d37/class_blinky_simulator_h_w_platform.html" title=" " alt="" coords="788,749,1001,1049"/>
<area shape="rect"  href="../../d3/d4c/class_unit_test_h_w_platform.html" title="Unit Test (Simulated) hardware platform." alt="" coords="1050,816,1219,983"/>
</map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a27a3e83c46a815179b0a3062e449d1eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a27a3e83c46a815179b0a3062e449d1eb">VirtualHwPlatformBase</a> (const char *<a class="el" href="../../de/de8/group___framework_hw_platform.html#a725192e3e5638664b8c726eb9e633541">name</a>) noexcept</td></tr>
<tr class="memdesc:a27a3e83c46a815179b0a3062e449d1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a named virtual hardware platform.  <a href="#a27a3e83c46a815179b0a3062e449d1eb">More...</a><br /></td></tr>
<tr class="separator:a27a3e83c46a815179b0a3062e449d1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bf0e3d52657ba5fad2e3969d2b2acc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a96bf0e3d52657ba5fad2e3969d2b2acc">VirtualHwPlatformBase</a> (const std::string &amp;<a class="el" href="../../de/de8/group___framework_hw_platform.html#a725192e3e5638664b8c726eb9e633541">name</a>) noexcept</td></tr>
<tr class="memdesc:a96bf0e3d52657ba5fad2e3969d2b2acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a named virtual hardware platform.  <a href="#a96bf0e3d52657ba5fad2e3969d2b2acc">More...</a><br /></td></tr>
<tr class="separator:a96bf0e3d52657ba5fad2e3969d2b2acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d594b5a47cb7c0b76254d8283bf989"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#af8d594b5a47cb7c0b76254d8283bf989">VirtualHwPlatformBase</a> (const std::string_view &amp;<a class="el" href="../../de/de8/group___framework_hw_platform.html#a725192e3e5638664b8c726eb9e633541">name</a>) noexcept</td></tr>
<tr class="memdesc:af8d594b5a47cb7c0b76254d8283bf989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a named virtual hardware platform.  <a href="#af8d594b5a47cb7c0b76254d8283bf989">More...</a><br /></td></tr>
<tr class="separator:af8d594b5a47cb7c0b76254d8283bf989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3cfee0ffc309e67ae60dce422864a1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afa3cfee0ffc309e67ae60dce422864a1">~VirtualHwPlatformBase</a> ()=default</td></tr>
<tr class="memdesc:afa3cfee0ffc309e67ae60dce422864a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#afa3cfee0ffc309e67ae60dce422864a1">More...</a><br /></td></tr>
<tr class="separator:afa3cfee0ffc309e67ae60dce422864a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101d3e8cc746b7d984b7fabccc469268"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a101d3e8cc746b7d984b7fabccc469268">VirtualHwPlatformBase</a> (const <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:a101d3e8cc746b7d984b7fabccc469268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a101d3e8cc746b7d984b7fabccc469268">More...</a><br /></td></tr>
<tr class="separator:a101d3e8cc746b7d984b7fabccc469268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f999a0961170ad6bf940b6d7fa318a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a76f999a0961170ad6bf940b6d7fa318a">operator=</a> (const <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> &amp;)=delete</td></tr>
<tr class="memdesc:a76f999a0961170ad6bf940b6d7fa318a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#a76f999a0961170ad6bf940b6d7fa318a">More...</a><br /></td></tr>
<tr class="separator:a76f999a0961170ad6bf940b6d7fa318a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3171a7746d06d48d8191b98fcc878a22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a3171a7746d06d48d8191b98fcc878a22">VirtualHwPlatformBase</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:a3171a7746d06d48d8191b98fcc878a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move constructor.  <a href="#a3171a7746d06d48d8191b98fcc878a22">More...</a><br /></td></tr>
<tr class="separator:a3171a7746d06d48d8191b98fcc878a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa124908e8990bdf6fa2b9cc882f45f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afa124908e8990bdf6fa2b9cc882f45f2">operator=</a> (<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> &amp;&amp;)=delete</td></tr>
<tr class="memdesc:afa124908e8990bdf6fa2b9cc882f45f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted move assignment operator.  <a href="#afa124908e8990bdf6fa2b9cc882f45f2">More...</a><br /></td></tr>
<tr class="separator:afa124908e8990bdf6fa2b9cc882f45f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725192e3e5638664b8c726eb9e633541"><td class="memItemLeft" align="right" valign="top">constexpr const std::string_view &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a725192e3e5638664b8c726eb9e633541">name</a> () const noexcept</td></tr>
<tr class="memdesc:a725192e3e5638664b8c726eb9e633541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Virtual HW Platform's name.  <a href="#a725192e3e5638664b8c726eb9e633541">More...</a><br /></td></tr>
<tr class="separator:a725192e3e5638664b8c726eb9e633541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304aa670dd23732080bf62013fc09cb1"><td class="memItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a304aa670dd23732080bf62013fc09cb1">name_cstr</a> () const noexcept</td></tr>
<tr class="memdesc:a304aa670dd23732080bf62013fc09cb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the platform name as a cstring for C API compatibility.  <a href="#a304aa670dd23732080bf62013fc09cb1">More...</a><br /></td></tr>
<tr class="separator:a304aa670dd23732080bf62013fc09cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9ab99bca3514a8e6a52ddf780d7b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#afa9ab99bca3514a8e6a52ddf780d7b91">initProcessor</a> () noexcept</td></tr>
<tr class="memdesc:afa9ab99bca3514a8e6a52ddf780d7b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the processor.  <a href="#afa9ab99bca3514a8e6a52ddf780d7b91">More...</a><br /></td></tr>
<tr class="separator:afa9ab99bca3514a8e6a52ddf780d7b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b5619e91df4494eef7f985fc7e7df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#aa6b5619e91df4494eef7f985fc7e7df5">init</a> () noexcept</td></tr>
<tr class="memdesc:aa6b5619e91df4494eef7f985fc7e7df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the hardware platform.  <a href="#aa6b5619e91df4494eef7f985fc7e7df5">More...</a><br /></td></tr>
<tr class="separator:aa6b5619e91df4494eef7f985fc7e7df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac387625f52629b1f986f0842bc91ee46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ac387625f52629b1f986f0842bc91ee46">soft_reset</a> () noexcept</td></tr>
<tr class="memdesc:ac387625f52629b1f986f0842bc91ee46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a soft reset of the system (chip reset)  <a href="#ac387625f52629b1f986f0842bc91ee46">More...</a><br /></td></tr>
<tr class="separator:ac387625f52629b1f986f0842bc91ee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59206c1b92e55cadc8ecefe231ea18ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a59206c1b92e55cadc8ecefe231ea18ca">hard_reset</a> () noexcept</td></tr>
<tr class="memdesc:a59206c1b92e55cadc8ecefe231ea18ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a hard reset of the system (power cycle)  <a href="#a59206c1b92e55cadc8ecefe231ea18ca">More...</a><br /></td></tr>
<tr class="separator:a59206c1b92e55cadc8ecefe231ea18ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9bd46ed67bb876c667092f269a2d46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#a3b9bd46ed67bb876c667092f269a2d46">shutdown</a> () noexcept</td></tr>
<tr class="memdesc:a3b9bd46ed67bb876c667092f269a2d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the system.  <a href="#a3b9bd46ed67bb876c667092f269a2d46">More...</a><br /></td></tr>
<tr class="separator:a3b9bd46ed67bb876c667092f269a2d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Static Public Member Functions</h3></td></tr>
<tr class="memitem:acea0f10162d152d43d63ad06f6bcde91"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#acea0f10162d152d43d63ad06f6bcde91">earlyInitHook</a> () noexcept</td></tr>
<tr class="memdesc:acea0f10162d152d43d63ad06f6bcde91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform any special initialization steps.  <a href="#acea0f10162d152d43d63ad06f6bcde91">More...</a><br /></td></tr>
<tr class="separator:acea0f10162d152d43d63ad06f6bcde91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:ac8da07178a3acf5052d583e6b545ca60"><td class="memItemLeft" align="right" valign="top">const std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/de8/group___framework_hw_platform.html#ac8da07178a3acf5052d583e6b545ca60">name_</a></td></tr>
<tr class="separator:ac8da07178a3acf5052d583e6b545ca60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a27a3e83c46a815179b0a3062e449d1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a3e83c46a815179b0a3062e449d1eb">&#9670;&nbsp;</a></span>VirtualHwPlatformBase() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a named virtual hardware platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>C-string containing the hardware platform name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96bf0e3d52657ba5fad2e3969d2b2acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bf0e3d52657ba5fad2e3969d2b2acc">&#9670;&nbsp;</a></span>VirtualHwPlatformBase() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a named virtual hardware platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>std::string containing the hardware platform name Note: <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base" title="Virtual Hardware Platform Base.">VirtualHwPlatformBase</a> uses a std::string_view, so the std::string must remain valid throughout the lifetime of <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base" title="Virtual Hardware Platform Base.">VirtualHwPlatformBase</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8d594b5a47cb7c0b76254d8283bf989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d594b5a47cb7c0b76254d8283bf989">&#9670;&nbsp;</a></span>VirtualHwPlatformBase() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a named virtual hardware platform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>std::string_view containing the hardware platform name Note: <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base" title="Virtual Hardware Platform Base.">VirtualHwPlatformBase</a> uses a std::string_view, so the std::string_view must remain valid throughout the lifetime of <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base" title="Virtual Hardware Platform Base.">VirtualHwPlatformBase</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa3cfee0ffc309e67ae60dce422864a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3cfee0ffc309e67ae60dce422864a1">&#9670;&nbsp;</a></span>~VirtualHwPlatformBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::~<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<a id="a101d3e8cc746b7d984b7fabccc469268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101d3e8cc746b7d984b7fabccc469268">&#9670;&nbsp;</a></span>VirtualHwPlatformBase() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a>&lt; THWPlatform &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="a3171a7746d06d48d8191b98fcc878a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3171a7746d06d48d8191b98fcc878a22">&#9670;&nbsp;</a></span>VirtualHwPlatformBase() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::<a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a>&lt; THWPlatform &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move constructor. </p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="acea0f10162d152d43d63ad06f6bcde91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea0f10162d152d43d63ad06f6bcde91">&#9670;&nbsp;</a></span>earlyInitHook()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::earlyInitHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform any special initialization steps. </p>
<p>The earlyInitHook_() function must be implemented by the derived class as a static function.</p>
<p>These functions run before the C Run-time setup functions are called, and normal functionality (e.g. OS concepts) are not available.</p>
<p>Early initialization steps represent any super early code that needs to execute. For example, DRAM might need to be initialized before the boot process can relocate memory to its proper location in memory.</p>
<p>These functions are declared static to prevent you from easily using drivers within their confines </p>

</div>
</div>
<a id="a59206c1b92e55cadc8ecefe231ea18ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59206c1b92e55cadc8ecefe231ea18ca">&#9670;&nbsp;</a></span>hard_reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::hard_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a hard reset of the system (power cycle) </p>
<p>The hard_reset_() function must be implemented by the derived class.</p>
<p>A hard reset is intended to perform a full power cycle of the system.</p>
<p>Platforms which do not support a hard reset should default to calling <a class="el" href="../../de/de8/group___framework_hw_platform.html#ac387625f52629b1f986f0842bc91ee46" title="Perform a soft reset of the system (chip reset)">soft_reset()</a>. </p>

</div>
</div>
<a id="aa6b5619e91df4494eef7f985fc7e7df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b5619e91df4494eef7f985fc7e7df5">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the hardware platform. </p>
<p>The init_() function must be implemented by the derived class.</p>
<p>Perform any hardware platform initialization steps, such as preparing peripherals for use, setting up callbacks, etc. </p>

<p class="reference">Referenced by <a class="el" href="../../de/dfa/classn_r_f52_d_k___framework_demo_platform.html#a73b3eae90e29ef95daa4f495e2e47472">nRF52DK_FrameworkDemoPlatform::initHWPlatform_()</a>, <a class="el" href="../../d9/dfd/class_framework_demo_sim_platform.html#a8b9203b7a676567a4ff20b02d1b0f729">FrameworkDemoSimPlatform::initHWPlatform_()</a>, and <a class="el" href="../../dd/d7e/class_unit_test_platform.html#abb07e196c2d5bbf09774b4d8b57df5d3">UnitTestPlatform::initHWPlatform_()</a>.</p>

</div>
</div>
<a id="afa9ab99bca3514a8e6a52ddf780d7b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa9ab99bca3514a8e6a52ddf780d7b91">&#9670;&nbsp;</a></span>initProcessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::initProcessor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the processor. </p>
<p>The initProcessor_() function must be implemented by the derived class.</p>
<p>Perform any steps necessary for initializing the processor &amp; processor peripheral devices for use.</p>
<p>Note that this is only intended to be processor initialization. Platform initialization nis handled by the <a class="el" href="../../de/de8/group___framework_hw_platform.html#aa6b5619e91df4494eef7f985fc7e7df5" title="Initialize the hardware platform.">init()</a> function.</p>
<p>This function will likely invoke the VirtualProcessor::init() function, but the order and actual initialization process is left to the derived class. </p>

<p class="reference">Referenced by <a class="el" href="../../de/dfa/classn_r_f52_d_k___framework_demo_platform.html#ae37a80ca459484e3b1befe8c0f91abe2">nRF52DK_FrameworkDemoPlatform::initProcessor_()</a>, <a class="el" href="../../d9/dfd/class_framework_demo_sim_platform.html#aaf210439d598fe05e7559d6e05aa6843">FrameworkDemoSimPlatform::initProcessor_()</a>, and <a class="el" href="../../dd/d7e/class_unit_test_platform.html#ab7b5bc9ae609195c28dee040fd642e75">UnitTestPlatform::initProcessor_()</a>.</p>

</div>
</div>
<a id="a725192e3e5638664b8c726eb9e633541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a725192e3e5638664b8c726eb9e633541">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const std::string_view&amp; <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Virtual HW Platform's name. </p>

<p class="reference">Referenced by <a class="el" href="../../dd/d7e/class_unit_test_platform.html#a87531f7e0ebf040ab0dd7a65e2cd3a9b">UnitTestPlatform::hwPlatformName()</a>.</p>

</div>
</div>
<a id="a304aa670dd23732080bf62013fc09cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304aa670dd23732080bf62013fc09cb1">&#9670;&nbsp;</a></span>name_cstr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const char* <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::name_cstr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the platform name as a cstring for C API compatibility. </p>

<p class="reference">Referenced by <a class="el" href="../../dd/d7e/class_unit_test_platform.html#a748239df757cd37c8daf82ed1f9cdde9">UnitTestPlatform::hwPlatformName_cstr()</a>.</p>

</div>
</div>
<a id="a76f999a0961170ad6bf940b6d7fa318a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f999a0961170ad6bf940b6d7fa318a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a>&amp; <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a>&lt; THWPlatform &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a id="afa124908e8990bdf6fa2b9cc882f45f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa124908e8990bdf6fa2b9cc882f45f2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a>&amp; <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">VirtualHwPlatformBase</a>&lt; THWPlatform &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted move assignment operator. </p>

</div>
</div>
<a id="a3b9bd46ed67bb876c667092f269a2d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9bd46ed67bb876c667092f269a2d46">&#9670;&nbsp;</a></span>shutdown()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::shutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shutdown the system. </p>
<p>The shutdown_() function must be implemented by the derived class.</p>
<p>If your platform supports shutdown capability, take the proper steps to initiate a shutdown.</p>
<p>If the platform does not support shutdown capability, implement your shutdown_() function as an assert to notify users trying to call this API. You could also leave the shutdown_() function undefined. Anyone who calls the <a class="el" href="../../de/de8/group___framework_hw_platform.html#a3b9bd46ed67bb876c667092f269a2d46" title="Shutdown the system.">shutdown()</a> function on a platform with an undefined shutdown_() function will encounter a compiler error.</p>
<p>The shutdown function is not expected to return. </p>

</div>
</div>
<a id="ac387625f52629b1f986f0842bc91ee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac387625f52629b1f986f0842bc91ee46">&#9670;&nbsp;</a></span>soft_reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::soft_reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a soft reset of the system (chip reset) </p>
<p>The soft_reset_() function must be implemnted by the derived class.</p>
<p>A soft reset is intended to reset the program to the beginning without performing a full power cycle.</p>
<p>A good strategy is to just call virtual processor's reset() function, if one is provided. </p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="ac8da07178a3acf5052d583e6b545ca60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8da07178a3acf5052d583e6b545ca60">&#9670;&nbsp;</a></span>name_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THWPlatform&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string_view <a class="el" href="../../de/de8/group___framework_hw_platform.html#d0/d7f/classembvm_1_1_virtual_hw_platform_base">embvm::VirtualHwPlatformBase</a>&lt; THWPlatform &gt;::name_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../de/de8/group___framework_hw_platform.html#a725192e3e5638664b8c726eb9e633541">embvm::VirtualHwPlatformBase&lt; UnitTestHWPlatform &gt;::name()</a>, and <a class="el" href="../../de/de8/group___framework_hw_platform.html#a304aa670dd23732080bf62013fc09cb1">embvm::VirtualHwPlatformBase&lt; UnitTestHWPlatform &gt;::name_cstr()</a>.</p>

</div>
</div>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
