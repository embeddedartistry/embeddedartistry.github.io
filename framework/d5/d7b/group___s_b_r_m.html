<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry Framework: Scope-bound Resource Management</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Embedded Artistry Framework
   </div>
   <div id="projectbrief">Embedded Systems C++ Framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Scope-bound Resource Management<div class="ingroups"><a class="el" href="../../d3/dd5/group___framework_utils.html">Framework Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Utilties that enable SBRM techniques.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Scope-bound Resource Management:</div>
<div class="dyncontent">
<center><table><tr><td><img src="../../d5/d7b/group___s_b_r_m.jpg" border="0" alt="" usemap="#d5_2d7b_2group______s__b__r__m"/>
<map name="d5_2d7b_2group______s__b__r__m" id="d5_2d7b_2group______s__b__r__m">
<area shape="rect"  title="Utilties that enable SBRM techniques." alt="" coords="188,5,349,43"/>
<area shape="rect"  href="../../d3/dd5/group___framework_utils.html" title="Embedded Framework utility classes and functions." alt="" coords="5,12,140,36"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:dd/d04/class_scope_guard"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard&lt; TFunc &gt;</a></td></tr>
<tr class="memdesc:dd/d04/class_scope_guard"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a scope guard idiom to enable custom SBRM behaviors.  <a href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">More...</a><br /></td></tr>
<tr class="separator:dd/d04/class_scope_guard"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaa3ad2d904fdd999253a49380fabcaf97"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:gaa3ad2d904fdd999253a49380fabcaf97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#gaa3ad2d904fdd999253a49380fabcaf97">embutil::unique_ptr_aligned</a> = std::unique_ptr&lt; TType, decltype(&amp;<a class="el" href="../../d2/dfb/src_2aligned__malloc_8c.html#a274dd8714485eed9c9328973d44ec5dc">aligned_free</a>)&gt;</td></tr>
<tr class="memdesc:gaa3ad2d904fdd999253a49380fabcaf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique pointer alias for aligned memory (calls <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a>).  <a href="../../d5/d7b/group___s_b_r_m.html#gaa3ad2d904fdd999253a49380fabcaf97">More...</a><br /></td></tr>
<tr class="separator:gaa3ad2d904fdd999253a49380fabcaf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga4c70e65b5f4bef136004c307f5342ca1"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:ga4c70e65b5f4bef136004c307f5342ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#gaa3ad2d904fdd999253a49380fabcaf97">unique_ptr_aligned</a>&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga4c70e65b5f4bef136004c307f5342ca1">embutil::aligned_uptr</a> (<a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> align, <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> size)</td></tr>
<tr class="memdesc:ga4c70e65b5f4bef136004c307f5342ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a unique pointer to aligned memory.  <a href="../../d5/d7b/group___s_b_r_m.html#ga4c70e65b5f4bef136004c307f5342ca1">More...</a><br /></td></tr>
<tr class="separator:ga4c70e65b5f4bef136004c307f5342ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585e70b89827a5ea2f14a1037c92c549"><td class="memTemplParams" colspan="2">template&lt;typename TType &gt; </td></tr>
<tr class="memitem:ga585e70b89827a5ea2f14a1037c92c549"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; TType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga585e70b89827a5ea2f14a1037c92c549">embutil::aligned_sptr</a> (<a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> align, <a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a> size)</td></tr>
<tr class="memdesc:ga585e70b89827a5ea2f14a1037c92c549"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a shared pointer to aligned memory.  <a href="../../d5/d7b/group___s_b_r_m.html#ga585e70b89827a5ea2f14a1037c92c549">More...</a><br /></td></tr>
<tr class="separator:ga585e70b89827a5ea2f14a1037c92c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AcquisitionFunc , typename ReleaseFunc , typename... Args&gt; </td></tr>
<tr class="memitem:ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>, ReleaseFunc &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9">embutil::unique_resource</a> (AcquisitionFunc acquire, ReleaseFunc release, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::unique_ptr variant).  <a href="../../d5/d7b/group___s_b_r_m.html#ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9">More...</a><br /></td></tr>
<tr class="separator:ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f715bd30e54d8a578335b9f23f7e1c7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename AcquisitionFunc , typename ReleaseFunc , typename... Args&gt; </td></tr>
<tr class="memitem:ga8f715bd30e54d8a578335b9f23f7e1c7"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga8f715bd30e54d8a578335b9f23f7e1c7">embutil::shared_resource</a> (AcquisitionFunc acquire, ReleaseFunc release, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga8f715bd30e54d8a578335b9f23f7e1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::shared_ptr variant).  <a href="../../d5/d7b/group___s_b_r_m.html#ga8f715bd30e54d8a578335b9f23f7e1c7">More...</a><br /></td></tr>
<tr class="separator:ga8f715bd30e54d8a578335b9f23f7e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28065061c97acdea5eb567b64ed6a89"><td class="memTemplParams" colspan="2">template&lt;typename TFunctor &gt; </td></tr>
<tr class="memitem:gab28065061c97acdea5eb567b64ed6a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunctor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89">makeScopeGuard</a> (TFunctor &amp;&amp;func)</td></tr>
<tr class="memdesc:gab28065061c97acdea5eb567b64ed6a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create scope guard with provided functor.  <a href="#gab28065061c97acdea5eb567b64ed6a89">More...</a><br /></td></tr>
<tr class="separator:gab28065061c97acdea5eb567b64ed6a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="memTemplParams" colspan="2">template&lt;typename TFunc , typename... TParams&gt; </td></tr>
<tr class="memitem:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga79869db9aadf7c2f365f6728a7fbb9a2">makeScopeGuard</a> (TFunc &amp;&amp;func, TParams... args) -&gt; <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; decltype(std::bind(std::forward&lt; TFunc &gt;(func), std::forward&lt; TParams &gt;(args)...))&gt;</td></tr>
<tr class="memdesc:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create scope guard by binding the provided function and all the arguments.  <a href="#ga79869db9aadf7c2f365f6728a7fbb9a2">More...</a><br /></td></tr>
<tr class="separator:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Utilties that enable SBRM techniques. </p>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="dd/d04/class_scope_guard" id="dd/d04/class_scope_guard"></a>
<h2 class="memtitle"><span class="permalink"><a href="#dd/d04/class_scope_guard">&#9670;&nbsp;</a></span>ScopeGuard</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ScopeGuard</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename TFunc&gt;<br />
class ScopeGuard&lt; TFunc &gt;</h3>

<p>Provides a scope guard idiom to enable custom SBRM behaviors. </p>
<p>The scope guard idiom allows a user to call a function when the guard object is destructed. The guard class enables developes to implement custom SBRM behaviors.</p>
<p>The scope guard uses static memory allocation on the stack. The guard takes as much space on the stack as needed to bind the provided function with all its arguments.</p>
<h1>Using the scope guard</h1>
<p>In order to properly create a scope guard, you must use the <code><a class="el" href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89" title="Create scope guard with provided functor.">makeScopeGuard()</a></code> function.</p>
<div class="fragment"><div class="line"><span class="comment">// Binding function with parameters:</span></div><div class="line"><span class="keyword">auto</span> guard = <a class="code" href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89">makeScopeGuard</a>(&amp;func, std::ref(arg1), arg2);</div><div class="line"></div><div class="line"><span class="comment">// Binding lamda function:</span></div><div class="line"><span class="keyword">auto</span> guard = <a class="code" href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89">makeScopeGuard</a>([&amp;argByRef, argByValue]()</div><div class="line">{</div><div class="line">    <span class="comment">//guard code goes here</span></div><div class="line">});</div></div><!-- fragment --><p>Note that all the bound parameters are passed by value. To use references with the bound object, use std::ref() (or std::cref() for <code>const</code> reference).</p>
<p>The guard function can be manually called using the <code><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a8e752168baccab6527fd58b7d1cedd39" title="Release the bound functor.">release()</a></code> function.</p>
<p>A guard object only supports move semantics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunc</td><td>Functor object type. The template parameter must be type of the functor that doesn't receive any parameters and doesn't return any value. </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Public Member Functions</h3></td></tr>
<tr class="memitem:a3c00924f32796d8fe05fdaa4a087165c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a3c00924f32796d8fe05fdaa4a087165c">ScopeGuard</a> (TFunc &amp;&amp;func)</td></tr>
<tr class="memdesc:a3c00924f32796d8fe05fdaa4a087165c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a3c00924f32796d8fe05fdaa4a087165c">More...</a><br /></td></tr>
<tr class="separator:a3c00924f32796d8fe05fdaa4a087165c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204baa185e82fbd02e2bf478cd40b479"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a204baa185e82fbd02e2bf478cd40b479">ScopeGuard</a> (<a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> &amp;&amp;guard)</td></tr>
<tr class="memdesc:a204baa185e82fbd02e2bf478cd40b479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a204baa185e82fbd02e2bf478cd40b479">More...</a><br /></td></tr>
<tr class="separator:a204baa185e82fbd02e2bf478cd40b479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee25633e61e0602e15b44fed2e38211"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a6ee25633e61e0602e15b44fed2e38211">ScopeGuard</a> (const <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> &amp;)=delete</td></tr>
<tr class="memdesc:a6ee25633e61e0602e15b44fed2e38211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy constructor.  <a href="#a6ee25633e61e0602e15b44fed2e38211">More...</a><br /></td></tr>
<tr class="separator:a6ee25633e61e0602e15b44fed2e38211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56de2625159005933dd2d4d198f5fd81"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a56de2625159005933dd2d4d198f5fd81">operator=</a> (const <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> &amp;)=delete</td></tr>
<tr class="memdesc:a56de2625159005933dd2d4d198f5fd81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted copy assignment operator.  <a href="#a56de2625159005933dd2d4d198f5fd81">More...</a><br /></td></tr>
<tr class="separator:a56de2625159005933dd2d4d198f5fd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59132b37d3e58cfea6bebfdde1a8063f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a59132b37d3e58cfea6bebfdde1a8063f">~ScopeGuard</a> ()</td></tr>
<tr class="memdesc:a59132b37d3e58cfea6bebfdde1a8063f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a59132b37d3e58cfea6bebfdde1a8063f">More...</a><br /></td></tr>
<tr class="separator:a59132b37d3e58cfea6bebfdde1a8063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e752168baccab6527fd58b7d1cedd39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a8e752168baccab6527fd58b7d1cedd39">release</a> ()</td></tr>
<tr class="memdesc:a8e752168baccab6527fd58b7d1cedd39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the bound functor.  <a href="#a8e752168baccab6527fd58b7d1cedd39">More...</a><br /></td></tr>
<tr class="separator:a8e752168baccab6527fd58b7d1cedd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a540692c051ef55bd347c367720cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#af9a540692c051ef55bd347c367720cb6">isReleased</a> ()</td></tr>
<tr class="memdesc:af9a540692c051ef55bd347c367720cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the functor is released.  <a href="#af9a540692c051ef55bd347c367720cb6">More...</a><br /></td></tr>
<tr class="separator:af9a540692c051ef55bd347c367720cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Private Attributes</h3></td></tr>
<tr class="memitem:a79f8ce141faed960432a8ccee03537e9"><td class="memItemLeft" align="right" valign="top">std::remove_reference&lt; TFunc &gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a79f8ce141faed960432a8ccee03537e9">func_</a></td></tr>
<tr class="separator:a79f8ce141faed960432a8ccee03537e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac127279ef22995cc9814013a598cdb5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ac127279ef22995cc9814013a598cdb5c">active_</a></td></tr>
<tr class="separator:ac127279ef22995cc9814013a598cdb5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><h3>Related Functions</h3></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:gab28065061c97acdea5eb567b64ed6a89"><td class="memTemplParams" colspan="2">template&lt;typename TFunctor &gt; </td></tr>
<tr class="memitem:gab28065061c97acdea5eb567b64ed6a89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunctor &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89">makeScopeGuard</a> (TFunctor &amp;&amp;func)</td></tr>
<tr class="memdesc:gab28065061c97acdea5eb567b64ed6a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create scope guard with provided functor.  <a href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89">More...</a><br /></td></tr>
<tr class="separator:gab28065061c97acdea5eb567b64ed6a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="memTemplParams" colspan="2">template&lt;typename TFunc , typename... TParams&gt; </td></tr>
<tr class="memitem:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga79869db9aadf7c2f365f6728a7fbb9a2">makeScopeGuard</a> (TFunc &amp;&amp;func, TParams... args) -&gt; <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; decltype(std::bind(std::forward&lt; TFunc &gt;(func), std::forward&lt; TParams &gt;(args)...))&gt;</td></tr>
<tr class="memdesc:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create scope guard by binding the provided function and all the arguments.  <a href="../../d5/d7b/group___s_b_r_m.html#ga79869db9aadf7c2f365f6728a7fbb9a2">More...</a><br /></td></tr>
<tr class="separator:ga79869db9aadf7c2f365f6728a7fbb9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Constructor &amp; Destructor Documentation</h4>
<a id="a3c00924f32796d8fe05fdaa4a087165c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c00924f32796d8fe05fdaa4a087165c">&#9670;&nbsp;</a></span>ScopeGuard() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::<a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> </td>
          <td>(</td>
          <td class="paramtype">TFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor that will be executed when the scope guard is destructed (unless it is manually released). Functor must provide move/copy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe for distinct functors. </dd>
<dd>
Exception guarantee: nothrow if copy/move constructors of the bind arguments do not throw, Strong otherwise. </dd></dl>

</div>
</div>
<a id="a204baa185e82fbd02e2bf478cd40b479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204baa185e82fbd02e2bf478cd40b479">&#9670;&nbsp;</a></span>ScopeGuard() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::<a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>guard</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>After the functor is moved, it will be released in the provided guard.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">guard</td><td>The other scope guard of the same type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Unsafe </dd>
<dd>
Exception guarantee: nothrow if copy/move constructors of the bind arguments do not throw, Strong otherwise. </dd></dl>

</div>
</div>
<a id="a6ee25633e61e0602e15b44fed2e38211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee25633e61e0602e15b44fed2e38211">&#9670;&nbsp;</a></span>ScopeGuard() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::<a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy constructor. </p>

</div>
</div>
<a id="a59132b37d3e58cfea6bebfdde1a8063f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59132b37d3e58cfea6bebfdde1a8063f">&#9670;&nbsp;</a></span>~ScopeGuard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::~<a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The functor is called unless it was released with the <code><a class="el" href="../../d5/d7b/group___s_b_r_m.html#a8e752168baccab6527fd58b7d1cedd39" title="Release the bound functor.">release()</a></code> function prior to destruction. </dd></dl>

<p class="reference">References <a class="el" href="../../d5/d7b/group___s_b_r_m.html#a79f8ce141faed960432a8ccee03537e9">ScopeGuard&lt; TFunc &gt;::func_</a>, and <a class="el" href="../../d5/d7b/group___s_b_r_m.html#af9a540692c051ef55bd347c367720cb6">ScopeGuard&lt; TFunc &gt;::isReleased()</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Function Documentation</h4>
<a id="af9a540692c051ef55bd347c367720cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a540692c051ef55bd347c367720cb6">&#9670;&nbsp;</a></span>isReleased()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::isReleased </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether the functor is released. </p>
<dl class="section return"><dt>Returns</dt><dd>true in case of being released. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Unsafe </dd>
<dd>
Exception guarantee: No throw </dd></dl>

<p class="reference">References <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ac127279ef22995cc9814013a598cdb5c">ScopeGuard&lt; TFunc &gt;::active_</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d5/d7b/group___s_b_r_m.html#a59132b37d3e58cfea6bebfdde1a8063f">ScopeGuard&lt; TFunc &gt;::~ScopeGuard()</a>.</p>

</div>
</div>
<a id="a56de2625159005933dd2d4d198f5fd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56de2625159005933dd2d4d198f5fd81">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&amp; <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted copy assignment operator. </p>

</div>
</div>
<a id="a8e752168baccab6527fd58b7d1cedd39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e752168baccab6527fd58b7d1cedd39">&#9670;&nbsp;</a></span>release()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the bound functor. </p>
<dl class="section post"><dt>Postcondition</dt><dd>The functor won't be called when the scope guard is out of scope. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe on distinct objects. </dd>
<dd>
Exception guarantee: No throw. </dd></dl>

<p class="reference">References <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ac127279ef22995cc9814013a598cdb5c">ScopeGuard&lt; TFunc &gt;::active_</a>.</p>

</div>
</div>
<h4 class="groupheader">Member Data Documentation</h4>
<a id="ac127279ef22995cc9814013a598cdb5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac127279ef22995cc9814013a598cdb5c">&#9670;&nbsp;</a></span>active_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/d5e/stdbool_8h.html#afaa87723b8417d40fcf45b7330261ef9">bool</a> <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::active_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../d5/d7b/group___s_b_r_m.html#af9a540692c051ef55bd347c367720cb6">ScopeGuard&lt; TFunc &gt;::isReleased()</a>, and <a class="el" href="../../d5/d7b/group___s_b_r_m.html#a8e752168baccab6527fd58b7d1cedd39">ScopeGuard&lt; TFunc &gt;::release()</a>.</p>

</div>
</div>
<a id="a79f8ce141faed960432a8ccee03537e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f8ce141faed960432a8ccee03537e9">&#9670;&nbsp;</a></span>func_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::remove_reference&lt;TFunc&gt;::<a class="el" href="../../d8/d14/s__lroundl_8c.html#a53155e22eaa05190346890241be3367c">type</a> <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunc &gt;::func_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="../../d5/d7b/group___s_b_r_m.html#a59132b37d3e58cfea6bebfdde1a8063f">ScopeGuard&lt; TFunc &gt;::~ScopeGuard()</a>.</p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaa3ad2d904fdd999253a49380fabcaf97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ad2d904fdd999253a49380fabcaf97">&#9670;&nbsp;</a></span>unique_ptr_aligned</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d5/d7b/group___s_b_r_m.html#gaa3ad2d904fdd999253a49380fabcaf97">embutil::unique_ptr_aligned</a> = typedef std::unique_ptr&lt;TType, decltype(&amp;<a class="el" href="../../d2/dfb/src_2aligned__malloc_8c.html#a274dd8714485eed9c9328973d44ec5dc">aligned_free</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique pointer alias for aligned memory (calls <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a>). </p>
<p>This is an alias to aid the aligned pointer declaration. We specify that our alias has a fixed value: the deleter function type (<a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a>). We use this for the unique_ptr declaration, as it requires us to specify the type of the deleter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of data being allocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga585e70b89827a5ea2f14a1037c92c549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585e70b89827a5ea2f14a1037c92c549">&#9670;&nbsp;</a></span>aligned_sptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;TType&gt; embutil::aligned_sptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a shared pointer to aligned memory. </p>
<p>This template function simplifies our declarations of aligned shared pointers. Alignment and size are passed to <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#af9d29fa5731420020b36ffbf56e6de97" title="Allocated aligned memory.">aligned_malloc()</a>, and <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a> is always used as the deleter.</p>
<p>Notice here that the shared pointer doesn't need a special type declaration to work with a deleter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the data being allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>The desired alignment. align must be a power of 2. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the allocation in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::shared_ptr to aligned memory with <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a> configured as the deleter func. </dd></dl>

<p class="reference">References <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc">aligned_free()</a>, and <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#af9d29fa5731420020b36ffbf56e6de97">aligned_malloc()</a>.</p>

</div>
</div>
<a id="ga4c70e65b5f4bef136004c307f5342ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c70e65b5f4bef136004c307f5342ca1">&#9670;&nbsp;</a></span>aligned_uptr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#gaa3ad2d904fdd999253a49380fabcaf97">unique_ptr_aligned</a>&lt;TType&gt; embutil::aligned_uptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/ddb/aarch64_2include_2__types_2__size__t_8h.html#acf18a0d6c4b39d531e021702e9a77984">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a unique pointer to aligned memory. </p>
<p>This template function simplifies our declarations of aligned unique pointers. Alignment and size are passed to <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#af9d29fa5731420020b36ffbf56e6de97" title="Allocated aligned memory.">aligned_malloc()</a>. <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a> is always used as the deleter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TType</td><td>The type of the data being allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">align</td><td>The desired alignment. align must be a power of 2. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the allocation in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::unique_ptr to aligned memory with <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc" title="Free aligned memory.">aligned_free()</a> configured as the deleter func. </dd></dl>

<p class="reference">References <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#a274dd8714485eed9c9328973d44ec5dc">aligned_free()</a>, and <a class="el" href="../../d6/dfa/aligned__malloc_8h.html#af9d29fa5731420020b36ffbf56e6de97">aligned_malloc()</a>.</p>

</div>
</div>
<a id="gab28065061c97acdea5eb567b64ed6a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab28065061c97acdea5eb567b64ed6a89">&#9670;&nbsp;</a></span>makeScopeGuard() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunctor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt; TFunctor &gt; makeScopeGuard </td>
          <td>(</td>
          <td class="paramtype">TFunctor &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create scope guard with provided functor. </p>
<p>Use this function to create a scope guard with lambda function.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> guard = embxx::util::makeScopeGuard([&amp;argByRef, argByValue]()</div><div class="line">{</div><div class="line">  <span class="comment">//Some code here</span></div><div class="line"> });</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunctor</td><td>Functor type, should be deduced automatically </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scope guard. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Safe on distinct functors </dd>
<dd>
Exception guarantee: nothrow in case copy/move constructors of the bind arguments do not throw, Basic otherwise. </dd></dl>

</div>
</div>
<a id="ga79869db9aadf7c2f365f6728a7fbb9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79869db9aadf7c2f365f6728a7fbb9a2">&#9670;&nbsp;</a></span>makeScopeGuard() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TFunc , typename... TParams&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto makeScopeGuard </td>
          <td>(</td>
          <td class="paramtype">TFunc &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TParams...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="../../d5/d7b/group___s_b_r_m.html#dd/d04/class_scope_guard">ScopeGuard</a>&lt;decltype(std::bind(std::forward&lt;TFunc&gt;(func), std::forward&lt;TParams&gt;(args)...))&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create scope guard by binding the provided function and all the arguments. </p>
<p>Use this function to create a scope guard when a function with one or more arguments needs to be called.</p>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Binding function with parameters:</span></div><div class="line"><span class="keyword">auto</span> guard = <a class="code" href="../../d5/d7b/group___s_b_r_m.html#gab28065061c97acdea5eb567b64ed6a89">makeScopeGuard</a>(&amp;func, std::ref(arg1), arg2);</div></div><!-- fragment --><p>Note that all the bound parameters are passed by value. If there is any need to use references with the bound object, use <code>std::ref()</code> (or <code>std::cref()</code> to create a <code>const</code> reference).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TFunc</td><td>Pointer to function type </td></tr>
    <tr><td class="paramname">TParams</td><td>Types of other arguments. Variadic, so supports any number of arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>Functor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Function arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Scope guard. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread safety: Unsafe </dd>
<dd>
Exception guarantee: <code>nothrow</code> in case copy/move constructors of the bind arguments do not throw, Basic otherwise. </dd></dl>

</div>
</div>
<a id="ga8f715bd30e54d8a578335b9f23f7e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f715bd30e54d8a578335b9f23f7e1c7">&#9670;&nbsp;</a></span>shared_resource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AcquisitionFunc , typename ReleaseFunc , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>&gt; embutil::shared_resource </td>
          <td>(</td>
          <td class="paramtype">AcquisitionFunc&#160;</td>
          <td class="paramname"><em>acquire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReleaseFunc&#160;</td>
          <td class="paramname"><em>release</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::shared_ptr variant). </p>
<p>The <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga8f715bd30e54d8a578335b9f23f7e1c7" title="Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::shared_ptr variant).">shared_resource()</a> function creates unique pointers that manage C-style Resources. The function takes in an acquisiton function and release function (e.g. fopen and fclose). Remaining arguments are optional. If specified, they will be forwarded to the acquisition function.</p>
<p>The resource is created via the acquisition function and stored in a shared_ptr. When the shared_ptr refcount reaches 0, the delete function will be automatically called.</p>
<p>The <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga8f715bd30e54d8a578335b9f23f7e1c7" title="Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::shared_ptr variant).">shared_resource()</a> function returns a std::shared, and is intended for resources that have multiple owners.</p>
<h1>Using shared_resource</h1>
<p>You specify the storage type when invoking <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga8f715bd30e54d8a578335b9f23f7e1c7" title="Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::shared_ptr variant).">shared_resource()</a>. For example, if we want to manage a <code>FILE</code>:</p>
<div class="fragment"><div class="line">shared_resource&lt;FILE&gt;(...);</div></div><!-- fragment --><p>Note that we use <code>FILE</code> in the template invocation, rather than <code>FILE*</code>. std::shared_resource will actually manage a <code>FILE*</code> under the hood, and that's what the acquire function returns.</p>
<p>The full invocation requires us to specify arguments. In order to open a file we would normally use <a class="el" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen()</a>, and to close the file we use <a class="el" href="../../d6/dd1/stdio_8h.html#a6441bf0a1040701d1ba906b64f348daf">fclose()</a>. <a class="el" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen()</a> requires two arguments: a filename and the mode (e.g., read or write). We open a file <code>filename</code> for writing in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> sfile = embutil::shared_resource&lt;FILE&gt;(<a class="code" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen</a>, <a class="code" href="../../d6/dd1/stdio_8h.html#a6441bf0a1040701d1ba906b64f348daf">fclose</a>, filename, <span class="stringliteral">&quot;w&quot;</span>);</div></div><!-- fragment --><p>The resulting <code>sfile</code> can be passed into the C-style APIs using the std::shared_ptr <code>.get()</code> member function.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d6/dd1/stdio_8h.html#aef8568e2fe5d99bf0493f8ea855fbf2d">fwrite</a>(test_content, 1, <a class="code" href="../../da/d66/string_8h.html#a008e171a518fe0e0352f31b245e03875">strlen</a>(test_content), sfile.get());</div></div><!-- fragment --><p>When <code>sfile</code> goes out of scope, the resource will be automatically cleaned up by calling the <code>release</code> function on the managed pointer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the resource that will be created and managed. This type will actually be converted to a T*, which std::shared_ptr manages. </td></tr>
    <tr><td class="paramname">AcquisitionFunc</td><td>The function prototype for the function which is used to create or open the resource (e.g. <a class="el" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen()</a>). This type will be deduced from the function arguments. </td></tr>
    <tr><td class="paramname">ReleaseFunc</td><td>The function prototype for the function which is used to create or destroy the resource (e.g. <a class="el" href="../../d6/dd1/stdio_8h.html#a6441bf0a1040701d1ba906b64f348daf">fclose()</a>). This type will be deduced from the function arguments. </td></tr>
    <tr><td class="paramname">Args</td><td>Variadic list of arguments which will be forwarded to the AcquisitionFunc. This type will be deduced from the function arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acquire</td><td>The function used to acquire the resource. </td></tr>
    <tr><td class="paramname">release</td><td>The function used to release the resource. </td></tr>
    <tr><td class="paramname">args</td><td>A variadic list of arguments which will be forwarded to the acquire function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::shared_ptr which manages an instance of type T, configurd with release as the deleter function. When the std::shared_ptr refcount reaches 0, it will be automatically cleaned up via the release function. </dd></dl>

</div>
</div>
<a id="ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9">&#9670;&nbsp;</a></span>unique_resource()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename AcquisitionFunc , typename ReleaseFunc , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="../../d1/daa/k__tanf_8c.html#a3f23ef19f75a1358ade1d01a49060f77">T</a>, ReleaseFunc&gt; embutil::unique_resource </td>
          <td>(</td>
          <td class="paramtype">AcquisitionFunc&#160;</td>
          <td class="paramname"><em>acquire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReleaseFunc&#160;</td>
          <td class="paramname"><em>release</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::unique_ptr variant). </p>
<p>The <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9" title="Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::unique_ptr variant).">unique_resource()</a> function creates unique pointers that manage C-style Resources. The function takes in an acquisiton function and release function (e.g. fopen and fclose). Remaining arguments are optional. If specified, they will be forwarded to the acquisition function.</p>
<p>The resource is created via the acquisition function and stored in a unique_ptr. When the unique_ptr goes out of scope, the delete function will be automatically called.</p>
<p>The <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9" title="Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::unique_ptr variant).">unique_resource()</a> function returns a std::unique_ptr, and is intended for resources that have a single owner.</p>
<h1>Using unique_resource</h1>
<p>You specify the storage type when invoking <a class="el" href="../../d5/d7b/group___s_b_r_m.html#ga7ab7c45f4f35b0e7bd7a6afaf1ab43d9" title="Enable Scope-Bound Resource Management (SBRM) for C-style resources (std::unique_ptr variant).">unique_resource()</a>. For example, if we want to manage a <code>FILE</code>:</p>
<div class="fragment"><div class="line">unique_resource&lt;FILE&gt;(...);</div></div><!-- fragment --><p>Note that we use <code>FILE</code> in the template invocation, rather than <code>FILE*</code>. std::unique_ptr will actually manage a <code>FILE*</code> under the hood, and that's what the acquire function returns.</p>
<p>The full invocation requires us to specify arguments. In order to open a file we would normally use <a class="el" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen()</a>, and to close the file we use <a class="el" href="../../d6/dd1/stdio_8h.html#a6441bf0a1040701d1ba906b64f348daf">fclose()</a>. <a class="el" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen()</a> requires two arguments: a filename and the mode (e.g., read or write). We open a file <code>filename</code> for writing in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> ufile = embutil::unique_resource&lt;FILE&gt;(<a class="code" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen</a>, <a class="code" href="../../d6/dd1/stdio_8h.html#a6441bf0a1040701d1ba906b64f348daf">fclose</a>, filename, <span class="stringliteral">&quot;w&quot;</span>);</div></div><!-- fragment --><p>The resulting <code>ufile</code> can be passed into the C-style APIs using the std::unique_ptr <code>.get()</code> member function.</p>
<div class="fragment"><div class="line"><a class="code" href="../../d6/dd1/stdio_8h.html#aef8568e2fe5d99bf0493f8ea855fbf2d">fwrite</a>(test_content, 1, <a class="code" href="../../da/d66/string_8h.html#a008e171a518fe0e0352f31b245e03875">strlen</a>(test_content), ufile.get());</div></div><!-- fragment --><p>When <code>ufile</code> goes out of scope, the resource will be automatically cleaned up by calling the <code>release</code> function on the managed pointer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the resource that will be created and managed. This type will actually be converted to a T*, which std::unique_ptr manages. </td></tr>
    <tr><td class="paramname">AcquisitionFunc</td><td>The function prototype for the function which is used to create or open the resource (e.g. <a class="el" href="../../d6/dd1/stdio_8h.html#a4f88e21c8715922a8af104bcd5276c54">fopen()</a>). This type will be deduced from the function arguments. </td></tr>
    <tr><td class="paramname">ReleaseFunc</td><td>The function prototype for the function which is used to create or destroy the resource (e.g. <a class="el" href="../../d6/dd1/stdio_8h.html#a6441bf0a1040701d1ba906b64f348daf">fclose()</a>). This type will be deduced from the function arguments. </td></tr>
    <tr><td class="paramname">Args</td><td>Variadic list of arguments which will be forwarded to the AcquisitionFunc. This type will be deduced from the function arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">acquire</td><td>The function used to acquire the resource. </td></tr>
    <tr><td class="paramname">release</td><td>The function used to release the resource. </td></tr>
    <tr><td class="paramname">args</td><td>A variadic list of arguments which will be forwarded to the acquire function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::unique_ptr which manages an instance of type T, configurd with release as the deleter function. When the resource goes out of scope, it will be automatically cleaned up via the release function. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
